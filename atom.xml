<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江流的个人博客</title>
  <icon>https://www.gravatar.com/avatar/13672193897b3dfe5bec9baac0db5740</icon>
  <subtitle>一名落魄的Java程序员</subtitle>
  <link href="https://jiangliujl.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiangliujl.github.io/"/>
  <updated>2022-08-10T14:41:36.814Z</updated>
  <id>https://jiangliujl.github.io/</id>
  
  <author>
    <name>JiangLiu</name>
    <email>1794952398@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Java流操作》——读书笔记</title>
    <link href="https://jiangliujl.github.io/2022/08/10/Java%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://jiangliujl.github.io/2022/08/10/Java%E6%B5%81%E6%93%8D%E4%BD%9C/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-10T14:41:36.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h1><p>处理集合时，我们常常会遍历他们的元素，然后对其中的元素做一些操作，例如我们如果想从一个文件中读取一个字符串，然后用非字母对他们进行分割，我们一般会这么干</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 非字母分隔符</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">System.out.println(words);</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以尝试用流的操作替代循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 非字母分隔符</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">        System.out.println(words);</span><br><span class="line"><span class="comment">//        for (String word : words) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(word);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">long</span> count1 = words.stream().filter(Objects::nonNull).count();</span><br><span class="line">        System.out.println(count1);</span><br></pre></td></tr></table></figure><p>就像这样，这比循环更加简洁</p><h2 id="stream和parallelStream"><a href="#stream和parallelStream" class="headerlink" title="stream和parallelStream"></a>stream和parallelStream</h2><p>在Java中，这两种都是流操作，但是它们两个有一些区别</p><ul><li>stream是串行流，也就是说stream流中的元素是一个一个顺序执行的</li><li>而parallelStream是并行流，可以以并行方式来进行过滤和计数</li></ul><p>至于并行流，在后面会详细介绍</p><p>流操作表面上和集合是非常相似的，但是它们有着非常显著的差异：</p><ul><li>流操作并不存储元素。这些元素储存在底层的集合中按需生成。</li><li>流操作并不会修改数据源，而是产生一个新的流</li><li>流的操作是尽可能惰性执行的。比如我们想要查找前五个长单词而不是所有长单词，那么流就会在匹配到第五个长单词时停止过滤，因此按理说我们可以操作无限流。</li></ul><h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><p>流操作API：</p><ul><li>filter(Predicate&lt;? super T&gt; P)：产生一个流，其中包含所有满足P的元素</li><li>count()：计算当前流中元素的数量</li></ul><p>流的种类：</p><ul><li>stream：串行流</li><li>parallelStream：并行流</li></ul><h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><p>我们已经知道用Collection类的stream方法可以将一个集合转化为流，当然，不止集合，数组也可以</p><p>对于一个数组，我们可以使用Stream.of方法将数组转变为流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; a1 = Stream.of(a);</span><br></pre></td></tr></table></figure><p>of方法用的是可变参数，所以我们可以传入任意长度的数组</p><p>但是更加推荐Array.stream(array, from, to)方法，可以从数组的from到to创建一个流对象</p><p>如果想产生一个空的流，可以使用<code>Stream.empty()</code>方法</p><h2 id="为什么推荐Array-stream"><a href="#为什么推荐Array-stream" class="headerlink" title="为什么推荐Array.stream"></a>为什么推荐Array.stream</h2><p>对于对象类型的数组，Array.stream和Stream.of虽然有同样的返回，但是对于基本类型的数组，Stream.of.count返回的数组永远是1</p><p>对于这点可以自行验证。</p><h2 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h2><p>在Java8的流库中，有两个创建无限流的方法，generate和iterator</p><p>详细可以从另一篇博客《Java流中的generate与iterator》了解</p><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>iterator需要我们传入两个参数，<code>seed</code>和<code>initial element seed</code>，一个是初始值，一个是产生无限流的依据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; stream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(<span class="number">100</span>);</span><br><span class="line">System.out.println(Arrays.toString(stream.filter(n -&gt; n.compareTo(<span class="keyword">new</span> BigInteger(String.valueOf(<span class="number">170L</span>))) &lt; <span class="number">0</span>).toArray()));</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>generate则需要我们传入一个Supplier对象，里面可以定义规则，比iterator更加灵活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Stream.generate(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).limit(<span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stream1.toArray()));</span><br></pre></td></tr></table></figure><p>或者说，generate可以根据多个元素制定规则，而iterator只能根据一个元素</p><p>在Java中，产生流的方式还有很多，比如Pattern.splitStream()、Files.lines()</p><p>Pattern.splitStream可以根据正则表达式来分割字符串形成一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.complie(<span class="string">&quot;\\PL+&quot;</span>).splitAsStream(content)</span><br></pre></td></tr></table></figure><p>而Files.lines(path)方法则可以返回一个包含文件中所有行的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path))&#123;</span><br><span class="line">    <span class="comment">// Process line</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="章节总结-1"><a href="#章节总结-1" class="headerlink" title="章节总结"></a>章节总结</h2><p>操作流API：</p><ul><li>of(T… values)：根据给定数组产生一个流</li><li>empty()：产生一个空的流</li><li>generate()：产生一个无限流</li><li>iterator()：产生一个无限流</li></ul><p>java.util.Arrays：</p><ul><li>stream(T[] Arrays, int start, int end)：根据数组创建一个流</li></ul><p>java.util.regex.Pattern：</p><ul><li>splitAsStream(CharSequence input)：根据input产生一个流</li></ul><p>java.nio.file.Files：</p><ul><li>stream(Path path, [Charset c])：将指定文件中的行转化为流，并且可以设置指定字符集</li></ul><p>java.util.function.Supplier：</p><ul><li>get()：提供一个值，用于产生无限流</li></ul><h1 id="filter、map和flatMap"><a href="#filter、map和flatMap" class="headerlink" title="filter、map和flatMap"></a>filter、map和flatMap</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter可以从一个流中转换出一个流，其中的元素遵循某种规则，可以在<code>filter()</code>括号中定义这个规则，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = wordList.stream().filter(w -&gt; w.length &gt; <span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>这样这个流中就会只包含长度大于12的单词</p><p>filter更像是从一个流中筛选元素，组成另一个流</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>相比于filter，map虽然也是产生一个新的流，但是map是将原来的流中的元素进行转换，比如将words中的单词全部小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = wordList.stream().map(String::toLowerCase);</span><br></pre></td></tr></table></figure><p>或者你可以自定义一个函数，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 核心技术卷II.JavaSe8的流库.流方法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/10 21:24:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect = words.stream().map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; collect1 = words.stream().map(w -&gt; myMap(w).collect(Collectors.toList())).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">myMap</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            list.add(s.substring(i, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[abc, bcd, java, golang, rust]</span><br><span class="line">[[A, b, c], [B, c, d], [J, a, v, a], [G, o, L, a, n, g], [R, u, s, t]]</span><br></pre></td></tr></table></figure><p>但是这样每个单词都是一个List，我们可能并不想出现这种情况，这时候flatMap方法就派上用场了</p><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>flatMap可以将当前流中的所有元素拼接到一起返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect2 = words.stream().flatMap(w -&gt; myMap(w)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line">[A, b, c, B, c, d, J, a, v, a, G, o, L, a, n, g, R, u, s, t]</span><br></pre></td></tr></table></figure><h2 id="章节总结-2"><a href="#章节总结-2" class="headerlink" title="章节总结"></a>章节总结</h2><p>java.util.Stream：</p><ul><li>filter：产生一个流，其中包含当前流中所有满足条件的元素</li><li>map(Function&lt;? super T&gt; mapper)：产生一个流，其中包含将mapper应用于流中的每一个元素所产生的结果</li><li>flatMap(Function mapper)：产生一个流，其中包含将mapper应用于流中每一个元素所产生的结果的组合</li></ul><h1 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h1><h2 id="抽取流"><a href="#抽取流" class="headerlink" title="抽取流"></a>抽取流</h2><p>在介绍无限流的时候，有一个API叫<code>limit()</code>，这个API会产生一个新的流，并且在流运行到第n个元素时结束，对裁剪无限流非常好用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; collect = Stream.generate(Math::random).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><p>这个流就只包含五个随机数</p><p>而<code>stream.skip(long n)</code>API正好相反，这个API会在跳过前n个元素，对后面的元素进行截取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect1 = words.stream().skip(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">[Java, GoLang, Rust]</span><br></pre></td></tr></table></figure><p>返回的流跳过了前两个元素</p><h2 id="连接流"><a href="#连接流" class="headerlink" title="连接流"></a>连接流</h2><p>如果想要将两个Luis连接起来，可以使用<code>stream.contact(Stream a, Stream b)</code>将两个流进行连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; collect2 = Stream.concat(collect.stream(), collect1.stream()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">[<span class="number">0.19283510014488758</span>, <span class="number">0.986608060762175</span>, <span class="number">0.07406377892420113</span>, <span class="number">0.6737128935974602</span>, <span class="number">0.5210312651857187</span>, Java, GoLang, Rust]</span><br></pre></td></tr></table></figure><h2 id="章节总结-3"><a href="#章节总结-3" class="headerlink" title="章节总结"></a>章节总结</h2><p>本章一共介绍了三个API，两个抽取子流，一个拼接流</p><p>java.util.Stream：</p><ul><li>limit(long maxSize)：抽取流中最初的maxSize个元素，并返回一个新的流</li><li>skip(long n)：抽取流中除了前n个元素之前的元素，并返回一个新的流</li><li>contact(Stream a, Stream b)：拼接两个流，并返回一个新的流</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从迭代到流的操作&quot;&gt;&lt;a href=&quot;#从迭代到流的操作&quot; class=&quot;headerlink&quot; title=&quot;从迭代到流的操作&quot;&gt;&lt;/a&gt;从迭代到流的操作&lt;/h1&gt;&lt;p&gt;处理集合时，我们常常会遍历他们的元素，然后对其中的元素做一些操作，例如我们如果想从一个文件中</summary>
      
    
    
    
    
    <category term="Java" scheme="https://jiangliujl.github.io/tags/Java/"/>
    
    <category term="Java流" scheme="https://jiangliujl.github.io/tags/Java%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>《Go随机数》——学习笔记</title>
    <link href="https://jiangliujl.github.io/2022/08/09/go%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://jiangliujl.github.io/2022/08/09/go%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-08-09T13:10:22.638Z</updated>
    
    <content type="html"><![CDATA[<p>在GO语言中，提供了随机数的核心方法<code>rand</code>，但是go的随机数其实并不随机，是一个伪随机数，简单来说就是Go的随机数生成需要依赖种子值，对于相同的种子值产生的随机数顺序是相同的</p><p>为了产生一个随机数，我们需要给rand设置一个不重复种子，最好的选择当然就是时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Seed接收的是一个int64类型的数字，需要用Unix将time转换成int64类型</p><p>然后就可以使用rand.Intn(max int64)来进行取随机数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">randomInt := int64(rand.Intn(<span class="number">100</span>))</span><br><span class="line">fmt.Println(randomInt)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在GO语言中，提供了随机数的核心方法&lt;code&gt;rand&lt;/code&gt;，但是go的随机数其实并不随机，是一个伪随机数，简单来说就是Go的随机数生成需要依赖种子值，对于相同的种子值产生的随机数顺序是相同的&lt;/p&gt;
&lt;p&gt;为了产生一个随机数，我们需要给rand设置一个不重复种子</summary>
      
    
    
    
    
    <category term="GoLang" scheme="https://jiangliujl.github.io/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>《Java序列化与反序列化》</title>
    <link href="https://jiangliujl.github.io/2022/08/04/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://jiangliujl.github.io/2022/08/04/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-04T14:32:50.841Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新的系列，每天写一点自己的想法。</p><p>突然想起来之前在面试的时候，面试官问过我这么一个问题：Java中创建类实例有哪几种方法</p><ul><li>new</li><li>Java反射的newInstance</li><li>clone</li><li>反序列化</li></ul><p>然后面试官又问我：反序列化你用过吗</p><p>我就答不上来了，只知道有这个概念，具体怎么实现还真没去看过，今天来试一试</p><h2 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h2><p>这里随便来写一个，但是记得实现序列化接口<code>Serializable</code>，没啥技术含量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/4 15:38:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 需要序列化的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写序列化类"><a href="#编写序列化类" class="headerlink" title="编写序列化类"></a>编写序列化类</h2><p>这里主要用到的就是IO流，反序列化的处理可能不是那么妥当，但是又一直报警告，明天再处理一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/4 15:39:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableUtil</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(T obj, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        outputStream.writeObject(obj);</span><br><span class="line">        <span class="comment">// 用完记得关闭</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deSerialize</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        Object a = <span class="keyword">null</span>;</span><br><span class="line">        a = inputStream.readObject();</span><br><span class="line">        <span class="keyword">return</span> (T) a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写main方法"><a href="#编写main方法" class="headerlink" title="编写main方法"></a>编写main方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/4 15:38:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 造几个People</span></span><br><span class="line">        List&lt;People&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        people.add(<span class="keyword">new</span> People(<span class="string">&quot;张三&quot;</span>, <span class="number">15</span>));</span><br><span class="line">        people.add(<span class="keyword">new</span> People(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        String fileName = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        SerializableUtil&lt;List&lt;People&gt;&gt; s = <span class="keyword">new</span> SerializableUtil&lt;&gt;();</span><br><span class="line">        <span class="comment">// 对象序列化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.serialize(people, fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        List&lt;People&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = s.deSerialize(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[People(name=张三, age=15), People(name=李四, age=18)]</span><br></pre></td></tr></table></figure><p>完美</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一个新的系列，每天写一点自己的想法。&lt;/p&gt;
&lt;p&gt;突然想起来之前在面试的时候，面试官问过我这么一个问题：Java中创建类实例有哪几种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;Java反射的newInstance&lt;/li&gt;
&lt;li&gt;clone&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="每天写点啥" scheme="https://jiangliujl.github.io/tags/%E6%AF%8F%E5%A4%A9%E5%86%99%E7%82%B9%E5%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>《Redis实现客户端缓存》</title>
    <link href="https://jiangliujl.github.io/2022/07/31/redis%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98/"/>
    <id>https://jiangliujl.github.io/2022/07/31/redis%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-30T16:00:00.000Z</published>
    <updated>2022-07-31T04:44:01.240Z</updated>
    
    <content type="html"><![CDATA[<p>在redis中，客户端缓存支持又被成为跟踪，有两种实现模式：</p><ul><li>在默认模式下，服务器会记住给定客户端访问的键，并且在相同的键被修改时发送无效信息。这将占用服务器端内存，但是只会为客户端内存中可能存在的一组键发送无效信息</li><li>在广播模式下，服务器不会试图记住给定客户端访问的键，因此这种模式在服务器客户端不消耗任何内存。而客户端通过订阅前缀如<code>object:</code>或<code>user:</code>，并在键匹配订阅前缀是接收通知消息</li></ul><h1 id="默认模式"><a href="#默认模式" class="headerlink" title="默认模式"></a>默认模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在redis中，客户端缓存支持又被成为跟踪，有两种实现模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在默认模式下，服务器会记住给定客户端访问的键，并且在相同的键被修改时发送无效信息。这将占用服务器端内存，但是只会为客户端内存中可能存在的一组键发送无效信息&lt;/li&gt;
&lt;li&gt;在广播模式下</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://jiangliujl.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《RabbitMQ学习笔记》——读书笔记</title>
    <link href="https://jiangliujl.github.io/2022/07/27/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://jiangliujl.github.io/2022/07/27/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-26T16:00:00.000Z</published>
    <updated>2022-07-27T04:43:52.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h1><p>MQ是<code>Message Queue</code>的简称，就是一个消息队列，队列嘛，FIFO先进先出，与普通队列的区别就是，MQ中存放的是消息，并且它是一种跨进程的通信机制，用于上下游传递消息，能够实现上下游之间的解耦</p><h1 id="MQ在SpringBoot中的配置"><a href="#MQ在SpringBoot中的配置" class="headerlink" title="MQ在SpringBoot中的配置"></a>MQ在SpringBoot中的配置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">//</span> <span class="string">rabbitmq的地址</span></span><br><span class="line"><span class="attr">port:</span> <span class="string">//</span> <span class="string">mq的端口</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">//</span> <span class="string">mq的用户名</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">//</span> <span class="string">mq的密码</span></span><br><span class="line"><span class="attr">virtual-host:</span> <span class="string">//</span> <span class="string">虚拟消息服务器</span></span><br><span class="line"><span class="attr">publisher-confirms:</span> <span class="string">//</span> <span class="string">是否开启发送确认</span></span><br><span class="line"><span class="attr">publisher-returns:</span> <span class="string">//</span> <span class="string">是否开启发送失败退回</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">mandatory:</span> <span class="string">//</span> <span class="string">生产者是否启用强制消息</span></span><br><span class="line"><span class="attr">retry:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="string">//</span> <span class="string">生产者是否开启重启</span></span><br><span class="line"><span class="attr">listener:</span></span><br><span class="line"><span class="attr">acknowledge-mode:</span> <span class="string">//</span> <span class="string">消费者ack模式</span></span><br><span class="line"><span class="attr">retry:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="string">//</span> <span class="string">消费者是否重试</span></span><br><span class="line"><span class="attr">max-attempts:</span> <span class="string">//</span> <span class="string">消费者重试次数</span></span><br></pre></td></tr></table></figure><h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><h3 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual-host"></a>virtual-host</h3><p><code>virtualHost</code>虚拟消息服务器，每个virtualHost相当于一个独立的MQ服务器，每个VirtualHost之间消息是隔离的，exchange、queue、message不能互通</p><h3 id="publisher-confirms"><a href="#publisher-confirms" class="headerlink" title="publisher-confirms"></a>publisher-confirms</h3><p>这个配置是为了在MQ和生产者之间的消息能够可靠传输，是MQ的扩展</p><p>生产者推送消息到消息队列后，会触发两个回调函数<code>ConfirmCallback</code>和<code>ReturnCallback</code>，从消息推送的结果来看，一共有四种组合：</p><ul><li>消息推送到server，但是在server里找不到交换机</li><li>消息推送到server，找到了交换机但是找不到队列</li><li>消息推送到server了，交换机和队列都没找到</li><li>消息推送成功</li></ul><p>生产者和消费者确认详见后文</p><h1 id="生产者和消费者确认"><a href="#生产者和消费者确认" class="headerlink" title="生产者和消费者确认"></a>生产者和消费者确认</h1><p>由于MQ的传输协议方法无法确认生产者和消费者是否成功发布或者消费信息，所以生产者和消费者都需要一种传递和处理确认的机制</p><h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><h3 id="自动ACK"><a href="#自动ACK" class="headerlink" title="自动ACK"></a>自动ACK</h3><p>在MQ中有一种自动确认模式机制，消息发送成功后立即被视为传递成功，这种模式以更高的吞吐量来降低交付和消费者处理的安全性为代价，如果消费者的TCP连接或通道在消息发送成功之前关闭，那么消息就会丢失，所以这种方法被视为是不安全的。</p><p>在这个模式中，当方法没有异常执行完毕后，会对MQ发出ACK，若方法出现异常，会对MQ发出nack，消息重回队列。</p><h3 id="手动ACK"><a href="#手动ACK" class="headerlink" title="手动ACK"></a>手动ACK</h3><p>常用API：</p><ul><li>channel.basicAck(msg.getMessageProperties().getDeliveryTag(), false/true)<ul><li>消息确认，第一个参数是队列名称，第二个参数是multiple<ul><li>multiple：是否一次性ack所有deleveryTag的消息</li></ul></li></ul></li><li>channel.basicReject(deleveryTag, requeue)<ul><li>拒绝消息<ul><li>requeue：bool类型，false表示将这条消息丢弃，true表示消息重回队列</li></ul></li></ul></li><li>channel.basicNack(deliveryTag, multiple, requeue)<ul><li>拒绝消息<ul><li>deliveryTag：队列名称</li><li>multiple：是否拒绝deliveryTag的所有消息</li><li>requeue：是否返回队列</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是MQ&quot;&gt;&lt;a href=&quot;#什么是MQ&quot; class=&quot;headerlink&quot; title=&quot;什么是MQ&quot;&gt;&lt;/a&gt;什么是MQ&lt;/h1&gt;&lt;p&gt;MQ是&lt;code&gt;Message Queue&lt;/code&gt;的简称，就是一个消息队列，队列嘛，FIFO先进先出，与普通</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://jiangliujl.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="SpringBoot" scheme="https://jiangliujl.github.io/tags/SpringBoot/"/>
    
    <category term="RabbitMQ" scheme="https://jiangliujl.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>《Java流中的generate与iterator》——读书笔记</title>
    <link href="https://jiangliujl.github.io/2022/07/26/stream%E4%B8%AD%E7%9A%84generate%E4%B8%8Eiterator/"/>
    <id>https://jiangliujl.github.io/2022/07/26/stream%E4%B8%AD%E7%9A%84generate%E4%B8%8Eiterator/</id>
    <published>2022-07-25T16:00:00.000Z</published>
    <updated>2022-07-26T14:54:20.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java流中的generate与iterator"><a href="#Java流中的generate与iterator" class="headerlink" title="Java流中的generate与iterator"></a>Java流中的generate与iterator</h1><p>在Java流中，有两个创建无限流的方法：</p><ul><li>stream().generate()</li><li>stream().iterator()</li></ul><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>从源码中给的解释来看</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</span><br><span class="line">The first element (position 0) in the Stream will be the provided seed. For n &gt; 0, the element at position n, will be the result of applying the function f to the element at position n - 1.</span><br><span class="line">The action of applying f for one element happens-before the action of applying f for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.</span><br><span class="line">形参:</span><br><span class="line">seed – the initial element f – a function to be applied to the previous element to produce a new element</span><br><span class="line">返回值:</span><br><span class="line">a new sequential Stream</span><br></pre></td></tr></table></figure><p>iterator创建的无限流是根据<code>seed</code>与<code>initial element seed</code>来创建的，简单来说就是一个起始元素seed，一个创建的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; stream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE)).limit(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stream.filter(n -&gt; n.compareTo(<span class="keyword">new</span> BigInteger(String.valueOf(<span class="number">1794952398L</span>))) &lt; <span class="number">0</span>).toArray()));</span><br></pre></td></tr></table></figure><p>这里用limit来限制一下产生的无限流，否则无法正常输出</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>同样还是来看源码中给的解释</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.</span><br><span class="line">形参:</span><br><span class="line">s – the Supplier of generated elements</span><br><span class="line">返回值:</span><br><span class="line">a new infinite sequential unordered Stream</span><br></pre></td></tr></table></figure><p>对于generate来说，只提供给我们一个参数<code>Supplier</code>，翻译过来叫 供应商，里面存放着产生供应流的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Stream.generate(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).limit(<span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stream1.toArray()));</span><br></pre></td></tr></table></figure><p>这里同样用limit限制一下</p><p>至于具体的使用场景，后续会继续更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java流中的generate与iterator&quot;&gt;&lt;a href=&quot;#Java流中的generate与iterator&quot; class=&quot;headerlink&quot; title=&quot;Java流中的generate与iterator&quot;&gt;&lt;/a&gt;Java流中的generat</summary>
      
    
    
    
    
    <category term="Java" scheme="https://jiangliujl.github.io/tags/Java/"/>
    
    <category term="Java流" scheme="https://jiangliujl.github.io/tags/Java%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>《MyBatis 和 MyBatis Plus冲突问题》——解决模块</title>
    <link href="https://jiangliujl.github.io/2022/07/25/mybatisplus%E5%92%8Cmybatis%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>https://jiangliujl.github.io/2022/07/25/mybatisplus%E5%92%8Cmybatis%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-24T16:00:00.000Z</published>
    <updated>2022-07-25T04:45:02.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在工作的时候，遇到了一个奇怪的问题，使用 MyBatis Plus 的IService模板中的list对数据库进行操作时，报了个<code>Invalid bound statement (not found)</code></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>搜了半天，主要是以下几个问题：</p><ul><li>xml 的 namespace 不正确</li><li>Mapper.java 中的方法在 Mapper.xml 中不存在</li><li>xml 返回类型配置错误</li><li>没有构建成功</li></ul><p>但是这些问题都检查了，没问题，用 Maven Helper 查看了一下依赖冲突，看到项目中同时引入了mybatis和mybatisplus，具体冲突的包有三个：</p><ul><li>mapper-spring-boot-starter</li><li>mybatis-spring-boot-starter</li><li>mybatis-plus-extension</li></ul><p>首先，<code>mybatis-spring-boot-starter</code>包是用来连接mybatis和springboot的中间件，这个 mybatis-plus-boot-starter能够代替，冲突了，去掉</p><p>然后是 <code>mapper-spring-boot-starter</code>包，这个包是用来导入公共mapper模板的，具体作用暂时不知道，但是不去掉也不能运行</p><p>最后是<code>mybatis-plus-extension</code>，这个东西具体作用没查到，只知道他是mybatisplus的扩展插件，但是去掉之后service层的函数全都无法调用了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在工作的时候，遇到了一个奇怪的问题，使用 MyBatis Plus 的IService模板中的list对数据库进行操作时，报了个&lt;code&gt;</summary>
      
    
    
    
    
    <category term="MyBatis Plus" scheme="https://jiangliujl.github.io/tags/MyBatis-Plus/"/>
    
    <category term="SpringBoot" scheme="https://jiangliujl.github.io/tags/SpringBoot/"/>
    
    <category term="问题解决" scheme="https://jiangliujl.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>《Java常用注解》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/java%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://jiangliujl.github.io/2022/07/15/java%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:18:35.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h1><p>从Java EE 5 之后，Servlet增加了两个影响Servlet生命周期的注解：</p><ul><li>@PostConstruct</li><li>@PreConstruct</li></ul><h2 id="PostConstruct-1"><a href="#PostConstruct-1" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>被这个注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，被PostConstruct修饰的方法会在构造函数之后，init之前运行</p><h2 id="PreConstruct"><a href="#PreConstruct" class="headerlink" title="@PreConstruct"></a>@PreConstruct</h2><p>被这个注解修饰的方法会在服务器卸载Servlet的时候运行，并且只会调用一次，类似于destroy</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PostConstruct&quot;&gt;&lt;a href=&quot;#PostConstruct&quot; class=&quot;headerlink&quot; title=&quot;@PostConstruct&quot;&gt;&lt;/a&gt;@PostConstruct&lt;/h1&gt;&lt;p&gt;从Java EE 5 之后，Servlet增加了</summary>
      
    
    
    
    
    <category term="Java" scheme="https://jiangliujl.github.io/tags/Java/"/>
    
    <category term="注解" scheme="https://jiangliujl.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>《lambda表达式的语法》——读书笔记</title>
    <link href="https://jiangliujl.github.io/2022/07/15/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://jiangliujl.github.io/2022/07/15/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:15:27.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h1><p>了解过javax.swing.Timer函数和Comparator比较器的可以发现，这两个例子有一些共同点，都是将某一段代码块传到某个对象，如果可以直接传入一段代码块，那代码会变得非常简洁，但是Java并不支持这种方法，因为这会让Java语言变得一团糟</p><p>在 java 8 后，加入了lambda表达式，这是一个可传递的代码块,可以让某个接口不写实现类而直接使用</p><p>new Timer中需要传入一个ActionListener接口，实际上只是调用这个接口中的actionPerformed函数，Comparator也是同理</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = <span class="keyword">new</span> String[]&#123; <span class="string">&quot;Mercury&quot;</span> , <span class="string">&quot;Venus&quot;</span> , <span class="string">&quot;Earth&quot;</span> , <span class="string">&quot;Mars&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;Jupiter&quot;</span> , <span class="string">&quot;Saturn&quot;</span> , <span class="string">&quot;Uranus&quot;</span> , <span class="string">&quot;Neptune&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(a, (left, right) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> left.length() - right.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Timer t = <span class="keyword">new</span> Timer(<span class="number">100</span>, event -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">&quot;Quit&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>Java中已经有了很多封装代码块地接口，如AactionListener、Comparator，lambda与这些接口是兼容的</p><p>对于只有一个抽象方法的接口，需要用到这种接口的对象时，可以使用lambda表达式，这种接口成为函数式接口</p><ul><li>为什么Comparator接口也能成为函数式接口，明明有compare、equals两个抽象函数<ul><li>对于接口重写Object的公共方法是不算入函数式接口中的，也就是说Comparator只有compare一个非公共抽象函数</li></ul></li></ul><p>以Arrays.sort为例，在底层，sort方法会接收Comparator的某个类的对象，在这个对象上再调用compare方法执行lambda表达式的方法体。</p><p>lambda表达式可以转换成接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">100</span>, event -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>与原来的写法相比，这个可读性要高得多</p><p>实际上在Java中 lambda 表达式的作用非常有限，也只能转换为函数式接口，在其他语言中，可以声明函数类型、声明这些类型的变量，还可以使用变量保存函数表达式。</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>有时候我们希望可已经有现成的方法可以完成你想要传递到其他代码的某个动作，比如希望定时器事件打印这个事件对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event)):</span><br></pre></td></tr></table></figure><p>但是入股哟能直接把print方法传递到Timer构造器就更简洁了，lambda</p><p>表达式也能够做到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">100</span>, System.out::println);</span><br></pre></td></tr></table></figure><p><img src="/img/image-20220720173122252.png" alt="image-20220720173122252"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lambda表达式的语法&quot;&gt;&lt;a href=&quot;#lambda表达式的语法&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式的语法&quot;&gt;&lt;/a&gt;lambda表达式的语法&lt;/h1&gt;&lt;p&gt;了解过javax.swing.Timer函数和Compara</summary>
      
    
    
    
    
    <category term="Java" scheme="https://jiangliujl.github.io/tags/Java/"/>
    
    <category term="读书笔记" scheme="https://jiangliujl.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《MybatisPlus 常用注解》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/mybatisplus%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://jiangliujl.github.io/2022/07/15/mybatisplus%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:18:49.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h1><p>用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br></pre></td></tr></table></figure><p>描述：表名注解，标识实体类对应表</p><p>使用位置：实体类类注解</p><p>属性：</p><ul><li>value：表名</li><li>schema：用来指定模式名称，如果使用的是mysql，则指定数据库名称，如果使用oracle，则为schema</li><li>keepGlobalPrefix：是否保持使用全局的tablePrefix的值</li><li>resultMap：xml中resultMap的id</li><li>autoResultMap：是否自动构建ResultMap</li><li>excludeProperty：需要排除的属性名</li></ul><h1 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h1><p>用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br></pre></td></tr></table></figure><p> 描述：主键属性</p><p>使用位置：实体类主键字段</p><p>属性：</p><ul><li>value：主键字段名</li><li>type：指定主键类型</li></ul><h2 id="Type属性值"><a href="#Type属性值" class="headerlink" title="Type属性值"></a>Type属性值</h2><ul><li>AUTO：数据库ID自增</li><li>NONE：无状态，未设置主键类型（跟随全局，全局默认为INPUT）</li><li>INPUT：insert前自行设置</li><li>ASSIGN_ID：分配ID，使用接口<code>IdentifierGenerator</code>的<code>nextId</code>，实现类默认为雪花算法</li><li>ASSIGN_UUID：分配UUID</li></ul><h2 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h2><p>用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述：字段注解（非主键）</p><p>属性：</p><ul><li>value：数据库字段名</li><li>exist：是否为数据库字段</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TableName&quot;&gt;&lt;a href=&quot;#TableName&quot; class=&quot;headerlink&quot; title=&quot;@TableName&quot;&gt;&lt;/a&gt;@TableName&lt;/h1&gt;&lt;p&gt;用法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="注解" scheme="https://jiangliujl.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="Mybatis Plus" scheme="https://jiangliujl.github.io/tags/Mybatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>《事务传播行为》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
    <id>https://jiangliujl.github.io/2022/07/15/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:43:36.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是事务传播行为"><a href="#什么是事务传播行为" class="headerlink" title="什么是事务传播行为"></a>什么是事务传播行为</h1><p>我们在Spring中使用事务时，经常会在一个事务中调用另外一个事务，这种事务嵌套的控制方式就是事务传播行为</p><h1 id="事务传播行为的七种方式"><a href="#事务传播行为的七种方式" class="headerlink" title="事务传播行为的七种方式"></a>事务传播行为的七种方式</h1><ul><li>propagation_required<ul><li>事务传播的默认形式，如果当前没有事务，就新建一个事务，如果已经存在事务，就加入到这个事务中</li></ul></li><li>propagation_supports<ul><li>支持当前事务，如果当前没有事务，就以非事务方式执行</li></ul></li><li>propagation_mandatory<ul><li>使用当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>propagation_requires_new<ul><li>新建事务，如果当前存在事务，就把当前事务挂起</li></ul></li><li>propagation_not_supported<ul><li>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li></ul></li><li>propagation_never<ul><li>以非事务方式执行，如果当前存在事务，就抛出异常</li></ul></li><li>propagation_nested<ul><li>如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行propagation_required类似的操作</li></ul></li></ul><p>总结</p><p>如果事务嵌套，子事务回滚，如果子事务没有将父事务挂起，父事务也会回滚，不管父事务中是否有对子事务进行异常捕获</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是事务传播行为&quot;&gt;&lt;a href=&quot;#什么是事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;什么是事务传播行为&quot;&gt;&lt;/a&gt;什么是事务传播行为&lt;/h1&gt;&lt;p&gt;我们在Spring中使用事务时，经常会在一个事务中调用另外一个事务，这种事务嵌套的控</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://jiangliujl.github.io/tags/SpringBoot/"/>
    
    <category term="事务" scheme="https://jiangliujl.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="MySQL" scheme="https://jiangliujl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《事务失效》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8E%E5%8E%9F%E5%9B%A0/"/>
    <id>https://jiangliujl.github.io/2022/07/15/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8E%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:47:07.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务失效的几种情况与原因"><a href="#事务失效的几种情况与原因" class="headerlink" title="事务失效的几种情况与原因"></a>事务失效的几种情况与原因</h1><ul><li>service没有托管给spring</li><li>抛出受检异常</li><li>业务自己捕获了异常</li><li>切面顺序导致</li><li>非public方法</li><li>父子容器</li><li>方法被final修饰</li><li>方法被static修饰</li><li>调用本类方法</li><li>多线程调用</li><li>错误的传播行为</li><li>使用了不支持事务的存储引擎</li><li>数据源没有配置事务管理器</li><li>被代理的类过早实例化</li></ul><h2 id="service没有托管给spring"><a href="#service没有托管给spring" class="headerlink" title="service没有托管给spring"></a>service没有托管给spring</h2><p>事务的前提是service必须是一个bean对象</p><h2 id="抛出受检异常"><a href="#抛出受检异常" class="headerlink" title="抛出受检异常"></a>抛出受检异常</h2><p>spring默认回滚的是runtimeException，如果要触发其他异常的回滚，可以通过rollbackFor进行配置</p><h2 id="业务自己捕获了异常"><a href="#业务自己捕获了异常" class="headerlink" title="业务自己捕获了异常"></a>业务自己捕获了异常</h2><p>spring只有捕捉到了业务抛出的异常时，才会进行后续处理，如果业务自己捕获了异常并进行处理，事务无法感知</p><h2 id="切面顺序导致"><a href="#切面顺序导致" class="headerlink" title="切面顺序导致"></a>切面顺序导致</h2><p><img src="/img/image-20220713172742115.png" alt="image-20220713172742115"></p><p>因为spring事务本质上也是一个切面，自定义切面捕捉到了异常但是没有往外抛出，事务切面捕获不到异常</p><h2 id="非public方法"><a href="#非public方法" class="headerlink" title="非public方法"></a>非public方法</h2><p>spring事务默认生效的方法权限都必须为public</p><p>解决办法：</p><ul><li>修改方法为public</li><li>修改TransactionAttributeSource，将publicMethodsOnly修改为false</li><li>开启AspectJ代理</li></ul><h2 id="父子容器"><a href="#父子容器" class="headerlink" title="父子容器"></a>父子容器</h2><p>原因：子容器扫描范围过大，将未加事务配置的service扫描进来</p><p>这个一般用于spring整合springmvc中，springboot没有父子容器</p><h2 id="方法用final修饰"><a href="#方法用final修饰" class="headerlink" title="方法用final修饰"></a>方法用final修饰</h2><p>spring事务是用动态代理实现的，如果方法使用了final修饰，代理类无法对目标类进行重写，就无法实现事务</p><h2 id="方法用static修饰"><a href="#方法用static修饰" class="headerlink" title="方法用static修饰"></a>方法用static修饰</h2><p>原因和final一样</p><h2 id="调用本类方法"><a href="#调用本类方法" class="headerlink" title="调用本类方法"></a>调用本类方法</h2><p>调用本类方法不经过代理，就无法进行增强</p><h2 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h2><p>原因：spring的事务是通过数据库连接来实现的，而数据库连接spring是放在threadLocal里面的，同一个事务只能用同一个数据库连接。而多线程场景下，拿到的数据库连接不同，即属于不同事务</p><h2 id="错误的传播行为"><a href="#错误的传播行为" class="headerlink" title="错误的传播行为"></a>错误的传播行为</h2><p>详情看  事务传播行为</p><h2 id="使用了不支持事务的存储引擎"><a href="#使用了不支持事务的存储引擎" class="headerlink" title="使用了不支持事务的存储引擎"></a>使用了不支持事务的存储引擎</h2><p>比如mysql中的MyISAM就不支持事务</p><h2 id="数据源没有配置事务管理器"><a href="#数据源没有配置事务管理器" class="headerlink" title="数据源没有配置事务管理器"></a>数据源没有配置事务管理器</h2><p>springboot中默认开启事务管理器</p><h2 id="被代理的类被过早实例化"><a href="#被代理的类被过早实例化" class="headerlink" title="被代理的类被过早实例化"></a>被代理的类被过早实例化</h2><p>具体应该要看源码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务失效的几种情况与原因&quot;&gt;&lt;a href=&quot;#事务失效的几种情况与原因&quot; class=&quot;headerlink&quot; title=&quot;事务失效的几种情况与原因&quot;&gt;&lt;/a&gt;事务失效的几种情况与原因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;service没有托管给spring&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://jiangliujl.github.io/tags/SpringBoot/"/>
    
    <category term="事务" scheme="https://jiangliujl.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="MySQL" scheme="https://jiangliujl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《常用类与接口》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>https://jiangliujl.github.io/2022/07/15/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-24T08:46:35.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h1><p>遇到的问题：在开发中需要对一个含有实体类的泛型数组进行排序</p><p>comparator接口可以实现这个功能</p><p>简单用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (((String) o1).length() - ((String) o2).length());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h1><p>克隆接口，这个接口中提供了一个安全的clone方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Comparator接口&quot;&gt;&lt;a href=&quot;#Comparator接口&quot; class=&quot;headerlink&quot; title=&quot;Comparator接口&quot;&gt;&lt;/a&gt;Comparator接口&lt;/h1&gt;&lt;p&gt;遇到的问题：在开发中需要对一个含有实体类的泛型数组进行排序&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://jiangliujl.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《SpringBoot常用注解》</title>
    <link href="https://jiangliujl.github.io/2022/07/15/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://jiangliujl.github.io/2022/07/15/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-08-03T08:39:17.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot常用注解"><a href="#Springboot常用注解" class="headerlink" title="Springboot常用注解"></a>Springboot常用注解</h1><ul><li>Value：属性赋值</li><li>Component：与业务层、dao层、控制层不相关的类需要在spring容器中创建使用</li><li>Mapper：注解当前类为mapper类</li><li>MapperScan：如果想要每个接口都变成实现类，那么需要在每个接口上添加Mapper注解，比较麻烦，可以使用MapperScan进行扫描</li><li>Service：表示当前层为Service层</li><li>Controller：控制层对象的创建</li><li>RestController：Controller与ResponseBody的结合，让当前类下web请求返回数据而不是视图</li><li>Autowired：根据类型自动注入</li><li>Resouce：根据名称自动注入</li></ul><h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h2><p>这个注解包含了三个注解，分别是：</p><p>@SpringBootConfiguration：自动扫描添加了@Configuration注解的类，读取其中的配置信息</p><p>@EnableAutoConfiguration：开启自动配置告诉Springboot基于所添加的依赖去猜测你想要如何配置spring，比如说我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖，此时自动配置就只要你是要开发一个web应用，就会帮我们去完成web以及springMVC的默认配置。</p><p>@ComponentScan：配置组件扫描</p><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="@Transaction"></a>@Transaction</h2><p>事务注解</p><h3 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h3><p>具体看我的另一篇博客——《事务失效》</p><h2 id="EnableScheduling"><a href="#EnableScheduling" class="headerlink" title="@EnableScheduling"></a>@EnableScheduling</h2><p>开启定时任务，配合@Schedule注解使用，使这个注解功能可用</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>告诉方法产生一个bean对象，然后将这个bean交给spring进行管理，在产生bean的时候这个方法会调用一次，然后将产生的bean对象放入spring容器中</p><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>在spring中，有一个接口叫<code>InitializationBean</code>，这个接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，并且在这个接口中有一个定义好的初始化方法<code>afterPropertiesSet</code></p><p><strong>但是</strong>，spring并不推荐使用这种方法来调用初始化，它会将不必要的代码耦合到spring</p><p>相比于<code>InitializationBean</code>，spring更推荐我们使用<code>@PostConstruct</code>注解</p><p>至于为什么推荐使用<code>@PostConstruct</code>：</p><ul><li>InitializationBean是直接执行方法来进行初始化的，会耦合进Spring项目</li><li>@PostConstruct注解是通过反射机制来初始化的</li></ul><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>在SpringBoot中，如果我们想要获取到配置文件中某个属性的值，有两个方法：</p><ul><li>@Value</li><li>@ConfigurationProperties</li></ul><p>这里我们只介绍第二个</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">JiangLiu</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><p>如果我们想要获取username，只需要这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><p><code>@Autowired</code>注解可以帮助我们进行spring依赖注入，但是很多场景下只用这个注解，spring并不知道我们需要注入哪个bean，比如B、C两个类同时继承A接口，这时我们注入A，spring就会抛出<code>NoUniqueBeanDefinitionException</code>异常，这时就需要使用@Qualifier注解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Springboot常用注解&quot;&gt;&lt;a href=&quot;#Springboot常用注解&quot; class=&quot;headerlink&quot; title=&quot;Springboot常用注解&quot;&gt;&lt;/a&gt;Springboot常用注解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Value：属性赋值&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="注解" scheme="https://jiangliujl.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="SpringBoot" scheme="https://jiangliujl.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
