[{"title":"《RabbitMQ学习笔记》——读书笔记","url":"/2022/07/27/RabbitMQ学习笔记/","content":"\n# 什么是MQ\n\nMQ是`Message Queue`的简称，就是一个消息队列，队列嘛，FIFO先进先出，与普通队列的区别就是，MQ中存放的是消息，并且它是一种跨进程的通信机制，用于上下游传递消息，能够实现上下游之间的解耦\n\n# MQ在SpringBoot中的配置\n\n```yaml\nspring:\n\trabbitmq:\n\t\thost: // rabbitmq的地址\n\t\tport: // mq的端口\n\t\tusername: // mq的用户名\n\t\tpassword: // mq的密码\n\t\tvirtual-host: // 虚拟消息服务器\n\t\tpublisher-confirms: // 是否开启发送确认\n\t\tpublisher-returns: // 是否开启发送失败退回\n\t\ttemplate:\n\t\t\tmandatory: // 生产者是否启用强制消息\n\t\t\tretry:\n\t\t\t\tenable: // 生产者是否开启重启\n\t\tlistener:\n\t\t\tacknowledge-mode: // 消费者ack模式\n\t\t\tretry:\n\t\t\t\tenable: // 消费者是否重试\n\t\t\t\tmax-attempts: // 消费者重试次数\n```\n\n## 配置详解\n\n### virtual-host\n\n`virtualHost`虚拟消息服务器，每个virtualHost相当于一个独立的MQ服务器，每个VirtualHost之间消息是隔离的，exchange、queue、message不能互通\n\n### publisher-confirms\n\n这个配置是为了在MQ和生产者之间的消息能够可靠传输，是MQ的扩展\n\n生产者推送消息到消息队列后，会触发两个回调函数`ConfirmCallback`和`ReturnCallback`，从消息推送的结果来看，一共有四种组合：\n\n+ 消息推送到server，但是在server里找不到交换机\n+ 消息推送到server，找到了交换机但是找不到队列\n+ 消息推送到server了，交换机和队列都没找到\n+ 消息推送成功\n\n生产者和消费者确认详见后文\n\n\n\n\n\n\n\n# 生产者和消费者确认\n\n由于MQ的传输协议方法无法确认生产者和消费者是否成功发布或者消费信息，所以生产者和消费者都需要一种传递和处理确认的机制\n\n## 消费者确认\n\n### 自动ACK\n\n在MQ中有一种自动确认模式机制，消息发送成功后立即被视为传递成功，这种模式以更高的吞吐量来降低交付和消费者处理的安全性为代价，如果消费者的TCP连接或通道在消息发送成功之前关闭，那么消息就会丢失，所以这种方法被视为是不安全的。\n\n在这个模式中，当方法没有异常执行完毕后，会对MQ发出ACK，若方法出现异常，会对MQ发出nack，消息重回队列。\n\n### 手动ACK\n\n常用API：\n\n+ channel.basicAck(msg.getMessageProperties().getDeliveryTag(), false/true)\n  + 消息确认，第一个参数是队列名称，第二个参数是multiple\n    + multiple：是否一次性ack所有deleveryTag的消息\n+ channel.basicReject(deleveryTag, requeue)\n  + 拒绝消息\n    + requeue：bool类型，false表示将这条消息丢弃，true表示消息重回队列\n+ channel.basicNack(deliveryTag, multiple, requeue)\n  + 拒绝消息\n    + deliveryTag：队列名称\n    + multiple：是否拒绝deliveryTag的所有消息\n    + requeue：是否返回队列\n","tags":["读书笔记","SpringBoot","RabbitMQ"]},{"title":"《Java流中的generate与iterator》——读书笔记","url":"/2022/07/26/stream中的generate与iterator/","content":"\n# Java流中的generate与iterator\n\n在Java流中，有两个创建无限流的方法：\n\n+ stream().generate()\n+ stream().iterator()\n\n## iterator\n\n从源码中给的解释来看\n\n```tex\nReturns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.\nThe first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.\nThe action of applying f for one element happens-before the action of applying f for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.\n形参:\nseed – the initial element f – a function to be applied to the previous element to produce a new element\n返回值:\na new sequential Stream\n```\n\niterator创建的无限流是根据`seed`与`initial element seed`来创建的，简单来说就是一个起始元素seed，一个创建的规则\n\n```java\nStream<BigInteger> stream = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE)).limit(10);\n        System.out.println(Arrays.toString(stream.filter(n -> n.compareTo(new BigInteger(String.valueOf(1794952398L))) < 0).toArray()));\n```\n\n这里用limit来限制一下产生的无限流，否则无法正常输出\n\n## generate\n\n同样还是来看源码中给的解释\n\n```tex\nReturns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.\n形参:\ns – the Supplier of generated elements\n返回值:\na new infinite sequential unordered Stream\n```\n\n对于generate来说，只提供给我们一个参数`Supplier`，翻译过来叫 供应商，里面存放着产生供应流的规则\n\n```java\nStream<Integer> stream1 = Stream.generate(new Supplier<Integer>() {\n            static int a = 0;\n\n            @Override\n            public Integer get() {\n                return a++;\n            }\n        }).limit(20);\n        System.out.println(Arrays.toString(stream1.toArray()));\n```\n\n这里同样用limit限制一下\n\n至于具体的使用场景，后续会继续更新\n","tags":["Java","Java流"]},{"title":"《MyBatis 和 MyBatis Plus冲突问题》——解决模块","url":"/2022/07/25/mybatisplus和mybatis冲突问题/","content":"\n# 问题\n\n在工作的时候，遇到了一个奇怪的问题，使用 MyBatis Plus 的IService模板中的list对数据库进行操作时，报了个`Invalid bound statement (not found)`\n\n# 解决\n\n搜了半天，主要是以下几个问题：\n\n+ xml 的 namespace 不正确\n+ Mapper.java 中的方法在 Mapper.xml 中不存在\n+ xml 返回类型配置错误\n+ 没有构建成功\n\n但是这些问题都检查了，没问题，用 Maven Helper 查看了一下依赖冲突，看到项目中同时引入了mybatis和mybatisplus，具体冲突的包有三个：\n\n+ mapper-spring-boot-starter\n+ mybatis-spring-boot-starter\n+ mybatis-plus-extension\n\n首先，`mybatis-spring-boot-starter`包是用来连接mybatis和springboot的中间件，这个 mybatis-plus-boot-starter能够代替，冲突了，去掉\n\n然后是 `mapper-spring-boot-starter`包，这个包是用来导入公共mapper模板的，具体作用暂时不知道，但是不去掉也不能运行\n\n最后是`mybatis-plus-extension`，这个东西具体作用没查到，只知道他是mybatisplus的扩展插件，但是去掉之后service层的函数全都无法调用了\n\n","tags":["MyBatis Plus","SpringBoot","问题解决"]},{"title":"《Java常用注解》","url":"/2022/07/15/java常用注解/","content":"\n# @PostConstruct\n\n从Java EE 5 之后，Servlet增加了两个影响Servlet生命周期的注解：\n\n+ @PostConstruct\n+ @PreConstruct\n\n## @PostConstruct\n\n被这个注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，被PostConstruct修饰的方法会在构造函数之后，init之前运行\n\n## @PreConstruct\n\n被这个注解修饰的方法会在服务器卸载Servlet的时候运行，并且只会调用一次，类似于destroy","tags":["Java","注解"]},{"title":"《lambda表达式的语法》——读书笔记","url":"/2022/07/15/lambda表达式/","content":"\n# lambda表达式的语法\n\n了解过javax.swing.Timer函数和Comparator比较器的可以发现，这两个例子有一些共同点，都是将某一段代码块传到某个对象，如果可以直接传入一段代码块，那代码会变得非常简洁，但是Java并不支持这种方法，因为这会让Java语言变得一团糟\n\n在 java 8 后，加入了lambda表达式，这是一个可传递的代码块,可以让某个接口不写实现类而直接使用\n\nnew Timer中需要传入一个ActionListener接口，实际上只是调用这个接口中的actionPerformed函数，Comparator也是同理\n\n案例：\n\n```java\npublic class lambdaTest {\n    public static void main(String[] args) {\n        String[] a = new String[]{ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" ,\n                \"Jupiter\" , \"Saturn\" , \"Uranus\" , \"Neptune\"};\n        Arrays.sort(a, (left, right) -> {\n            return left.length() - right.length();\n        });\n        System.out.println(a);\n\n        Timer t = new Timer(100, event ->{\n            System.out.println(new Date());\n        });\n        t.start();\n        JOptionPane.showMessageDialog(null, \"Quit\");\n        System.exit(0);\n    }\n}\n```\n\n# 函数式接口\n\nJava中已经有了很多封装代码块地接口，如AactionListener、Comparator，lambda与这些接口是兼容的\n\n对于只有一个抽象方法的接口，需要用到这种接口的对象时，可以使用lambda表达式，这种接口成为函数式接口\n\n+ 为什么Comparator接口也能成为函数式接口，明明有compare、equals两个抽象函数\n  + 对于接口重写Object的公共方法是不算入函数式接口中的，也就是说Comparator只有compare一个非公共抽象函数\n\n以Arrays.sort为例，在底层，sort方法会接收Comparator的某个类的对象，在这个对象上再调用compare方法执行lambda表达式的方法体。\n\nlambda表达式可以转换成接口\n\n```java\nTimer t = new Timer(100, event ->{\n    System.out.println(new Date());\n});\n```\n\n与原来的写法相比，这个可读性要高得多\n\n实际上在Java中 lambda 表达式的作用非常有限，也只能转换为函数式接口，在其他语言中，可以声明函数类型、声明这些类型的变量，还可以使用变量保存函数表达式。\n\n# 方法引用\n\n有时候我们希望可已经有现成的方法可以完成你想要传递到其他代码的某个动作，比如希望定时器事件打印这个事件对象\n\n```java\nTimer t = new Timer(1000, event -> System.out.println(event)):\n```\n\n但是入股哟能直接把print方法传递到Timer构造器就更简洁了，lambda\n\n表达式也能够做到\n\n```java\nTimer t = new Timer(100, System.out::println);\n```\n\n![image-20220720173122252](/img/image-20220720173122252.png)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","读书笔记"]},{"title":"《MybatisPlus 常用注解》","url":"/2022/07/15/mybatisplus常用注解/","content":"\n\n\n# @TableName\n\n用法\n\n```java\n@TableName(\"sys_user\")\n```\n\n描述：表名注解，标识实体类对应表\n\n使用位置：实体类类注解\n\n属性：\n\n+ value：表名\n+ schema：用来指定模式名称，如果使用的是mysql，则指定数据库名称，如果使用oracle，则为schema\n+ keepGlobalPrefix：是否保持使用全局的tablePrefix的值\n+ resultMap：xml中resultMap的id\n+ autoResultMap：是否自动构建ResultMap\n+ excludeProperty：需要排除的属性名\n\n# @TableId\n\n用法\n\n```java\n@TableName(\"sys_user\")\n```\n\n 描述：主键属性\n\n使用位置：实体类主键字段\n\n属性：\n\n+ value：主键字段名\n+ type：指定主键类型\n\n## Type属性值\n\n+ AUTO：数据库ID自增\n+ NONE：无状态，未设置主键类型（跟随全局，全局默认为INPUT）\n+ INPUT：insert前自行设置\n+ ASSIGN_ID：分配ID，使用接口`IdentifierGenerator`的`nextId`，实现类默认为雪花算法\n+ ASSIGN_UUID：分配UUID\n\n## @TableField\n\n用法\n\n```java\n@TableName(\"sys_user\")\npublic class User {\n    @TableId\n    private Long id;\n    @TableField(\"nickname\")\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n描述：字段注解（非主键）\n\n属性：\n\n+ value：数据库字段名\n+ exist：是否为数据库字段\n\n","tags":["注解","Mybatis Plus"]},{"title":"《事务传播行为》","url":"/2022/07/15/事务传播行为/","content":"\n# 什么是事务传播行为\n\n我们在Spring中使用事务时，经常会在一个事务中调用另外一个事务，这种事务嵌套的控制方式就是事务传播行为\n\n# 事务传播行为的七种方式\n\n+ propagation_required\n  + 事务传播的默认形式，如果当前没有事务，就新建一个事务，如果已经存在事务，就加入到这个事务中\n+ propagation_supports\n  + 支持当前事务，如果当前没有事务，就以非事务方式执行\n+ propagation_mandatory\n  + 使用当前事务，如果当前没有事务，就抛出异常\n+ propagation_requires_new\n  + 新建事务，如果当前存在事务，就把当前事务挂起\n+ propagation_not_supported\n  + 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n+ propagation_never\n  + 以非事务方式执行，如果当前存在事务，就抛出异常\n+ propagation_nested\n  + 如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行propagation_required类似的操作\n\n\n\n总结\n\n如果事务嵌套，子事务回滚，如果子事务没有将父事务挂起，父事务也会回滚，不管父事务中是否有对子事务进行异常捕获","tags":["SpringBoot","事务","MySQL"]},{"title":"《事务失效》","url":"/2022/07/15/事务失效的几种情况与原因/","content":"\n# 事务失效的几种情况与原因\n\n+ service没有托管给spring\n+ 抛出受检异常\n+ 业务自己捕获了异常\n+ 切面顺序导致\n+ 非public方法\n+ 父子容器\n+ 方法被final修饰\n+ 方法被static修饰\n+ 调用本类方法\n+ 多线程调用\n+ 错误的传播行为\n+ 使用了不支持事务的存储引擎\n+ 数据源没有配置事务管理器\n+ 被代理的类过早实例化\n\n## service没有托管给spring\n\n事务的前提是service必须是一个bean对象\n\n## 抛出受检异常\n\nspring默认回滚的是runtimeException，如果要触发其他异常的回滚，可以通过rollbackFor进行配置\n\n## 业务自己捕获了异常\n\nspring只有捕捉到了业务抛出的异常时，才会进行后续处理，如果业务自己捕获了异常并进行处理，事务无法感知\n\n## 切面顺序导致\n\n![image-20220713172742115](/img/image-20220713172742115.png)\n\n因为spring事务本质上也是一个切面，自定义切面捕捉到了异常但是没有往外抛出，事务切面捕获不到异常\n\n## 非public方法\n\nspring事务默认生效的方法权限都必须为public\n\n解决办法：\n\n+ 修改方法为public\n+ 修改TransactionAttributeSource，将publicMethodsOnly修改为false\n+ 开启AspectJ代理\n\n## 父子容器\n\n原因：子容器扫描范围过大，将未加事务配置的service扫描进来\n\n这个一般用于spring整合springmvc中，springboot没有父子容器\n\n## 方法用final修饰\n\nspring事务是用动态代理实现的，如果方法使用了final修饰，代理类无法对目标类进行重写，就无法实现事务\n\n## 方法用static修饰\n\n原因和final一样\n\n## 调用本类方法\n\n调用本类方法不经过代理，就无法进行增强\n\n## 多线程调用\n\n原因：spring的事务是通过数据库连接来实现的，而数据库连接spring是放在threadLocal里面的，同一个事务只能用同一个数据库连接。而多线程场景下，拿到的数据库连接不同，即属于不同事务\n\n## 错误的传播行为\n\n详情看  事务传播行为\n\n## 使用了不支持事务的存储引擎\n\n比如mysql中的MyISAM就不支持事务\n\n## 数据源没有配置事务管理器\n\nspringboot中默认开启事务管理器\n\n## 被代理的类被过早实例化\n\n具体应该要看源码","tags":["SpringBoot","事务","MySQL"]},{"title":"《常用类与接口》","url":"/2022/07/15/常用类与接口/","content":"\n# Comparator接口\n\n遇到的问题：在开发中需要对一个含有实体类的泛型数组进行排序\n\ncomparator接口可以实现这个功能\n\n简单用法：\n\n```java\npublic class Collections_ {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        list.add(\"tom\");\n        list.add(\"smith\");\n        list.add(\"king\");\n        list.add(\"king\");\n        list.add(\"king\");\n        list.add(\"milan\");\n\n        Collections.sort(list, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 instanceof String && o2 instanceof String){\n                    return (((String) o1).length() - ((String) o2).length());\n                }\n                return 0;\n            }\n        });\n        System.out.println(list);\n    }\n}\n```\n\n# Cloneable接口\n\n克隆接口，这个接口中提供了一个安全的clone方法","tags":["Java"]},{"title":"《原子类》","url":"/2022/07/15/LongAdder和AutomicLong的（待完成）/","content":"\n# LongAdder和AtomicLong\n\n要讲清楚这个，首先我们需要了解，什么是CAS机制\n\n## CAS机制\n\n首先来看这样一段代码\n\n```java\nprivate static int temp = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 2; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    for(int j = 0; j < 10; j++){\n                        temp++;\n                    }\n                }\n            }).start();\n        }\n        Thread.sleep(100);\n        System.out.println(temp);\n    }\n```\n\n这段代码的结果，temp不一定是20，因为这段代码是**非线程安全**的，然后我们再加上synchronized锁，再次尝试\n\n```java\npackage 原子类.引入;\n\n/**\n * @author JiangLiu\n * @Date 2022/7/28 22:37:49\n * @description\n */\npublic class main {\n    private static int temp = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 2; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    for(int j = 0; j < 10; j++){\n                        synchronized (main.class){\n                            temp++;\n                        }\n                    }\n                }\n            }).start();\n        }\n        Thread.sleep(100);\n        System.out.println(temp);\n    }\n}\n```\n\n这时候我们会发现，temp的值就会是20了，但是在大多数情况下，这并不是最优选择，原因很简单，性能问题：\n\n+ synchronized会让没有得到锁资源的进程进入BLOCKED状态，而拿到资源后会进入RUNNABLE状态，状态的切换涉及到操作系统用户模式和内核模式的转换，代价较高\n\n面对这种情况，我们可以使用原子类来进行操作\n\n+ 原子类：就是java.util.concurrent.atomic包下一系列以Atomic开头的包装类。\n\n这里我们以AtomicLong为例：\n\n```java\npackage 原子类.引入;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\n/**\n * @author JiangLiu\n * @Date 2022/7/28 22:37:49\n * @description\n */\npublic class main {\n\n    private static AtomicLong temp = new AtomicLong();\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 10; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    for(int j = 0; j < 100; j++){\n                        synchronized (main.class){\n                            temp.incrementAndGet();\n                        }\n                    }\n                }\n            }).start();\n        }\n        Thread.sleep(100);\n        System.out.println(temp);\n    }\n}\n\n```\n\n结果我们可以看到，使用原子类之后，同样可以保证结果正确，并且在大多数情况下，性能要比synchronized更好，而原子类的底层就是使用到了CAS机制。\n\nCAS，英文叫做Compare and set，比较和更新，下面我们来介绍CAS机制的原理\n\n### 原理\n\n在CAS机制中，有三个基本操作数，分别是V,A,B\n\n+ V：内存地址\n+ A：旧的预期值\n+ B：新的预期值\n\n预期值：就是程序预测地址V上的值应该是什么，如果V上的值和A相同，那么B替换V上的值，如果V上的值不符合旧的预期值，那么就要重新获取V上的当前值，并且重新计算要修改的值，这个过程我们成为自旋。\n\n### 缺点\n\nCAS机制的缺点：\n\n+ CPU开销过大\n  + 如果有多个线程竞争资源，却又一直更新失败，会给CPU带来很大压力\n+ 不能保证代码块的原子性\n  + 原子类只能保证一个变量的原子操作，如果想要三个原子类同时更新，就必须使用synchronized\n+ ABA问题\n  + 后面会进行详细介绍，这是CAS机制最大的问题\n\n","tags":["Java"]},{"title":"《SpringBoot常用注解》","url":"/2022/07/15/SpringBoot常用注解/","content":"\n# Springboot常用注解\n\n+ Value：属性赋值\n+ Component：与业务层、dao层、控制层不相关的类需要在spring容器中创建使用\n+ Mapper：注解当前类为mapper类\n+ MapperScan：如果想要每个接口都变成实现类，那么需要在每个接口上添加Mapper注解，比较麻烦，可以使用MapperScan进行扫描\n+ Service：表示当前层为Service层\n+ Controller：控制层对象的创建\n+ RestController：Controller与ResponseBody的结合，让当前类下web请求返回数据而不是视图\n+ Autowired：根据类型自动注入\n+ Resouce：根据名称自动注入\n\n## @SpringBootApplication注解\n\n这个注解包含了三个注解，分别是：\n\n@SpringBootConfiguration：自动扫描添加了@Configuration注解的类，读取其中的配置信息\n\n@EnableAutoConfiguration：开启自动配置告诉Springboot基于所添加的依赖去猜测你想要如何配置spring，比如说我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖，此时自动配置就只要你是要开发一个web应用，就会帮我们去完成web以及springMVC的默认配置。\n\n@ComponentScan：配置组件扫描\n\n## @Transaction\n\n事务注解\n\n### 失效场景\n\n具体看我的另一篇博客——《事务失效》\n\n## @EnableScheduling\n\n开启定时任务，配合@Schedule注解使用，使这个注解功能可用\n\n\n\n","tags":["注解","SpringBoot"]},{"title":"《Timer定时器》——源码阅读","url":"/2022/07/15/Timer定时器（待完成）/","content":"\n# Timer\n\n简单来说，Timer就像是一个闹钟，给定时器安排一个任务，约定这个任务在xxx时间后执行，可以执行一次或多次\n\nTimerTask是一个抽象类，它的子类代表一个可以被Timer计划的任务\n\nTimer一共有三个：\n\n+ javax.swing.Timer\n+ java.util.Timer\n+ javax.management.Timer\n\njava.util.Timer是最常用的\n\n## java.util.Timer\n\n在源码中，对Timer的介绍是这样的\n\n```tex\nA facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.\nCorresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially. Timer tasks should complete quickly. If a timer task takes excessive time to complete, it \"hogs\" the timer's task execution thread. This can, in turn, delay the execution of subsequent tasks, which may \"bunch up\" and execute in rapid succession when (and if) the offending task finally completes.\nAfter the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's cancel method.\nIf the timer's task execution thread terminates unexpectedly, for example, because its stop method is invoked, any further attempt to schedule a task on the timer will result in an IllegalStateException, as if the timer's cancel method had been invoked.\nThis class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.\nThis class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.\nJava 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.\nImplementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks.\nImplementation note: All constructors start a timer thread.\n```\n\n首先，Timer是为了以后在后台线程中执行任务的工具，任务可以执行一次或多次\n\nTimer中的所有任务都在一个线程中，用于按顺序执行所有定时器的任务，定时器任务应该设置为很快完成，否则它将占用其他任务的时间，相反也有好处，可以延后后续任务的执行。\n\n在一个Timer对象的最后一个引用消失并且所有任务都已完成后，Timer的线程会成为垃圾回收的对象。默认情况下，任务执行线程不作为守护线程。因此它能够防止应用程序终止\n\n如果定时器的任务线程意外终止。例如，调用了它的stop方法，那么任何进一步尝试在计时器上安排任务都将导致IllegalStateException，就如同调用了计时器的取消方法一样\n\nTimer这个类是线程安全的，多个线程可以共享一个Timer对象\n\n在 java 5.0 以后，Java引入了java.util.concurrent包，其中ScheduledThreadPoolExecutor是一个并发实用程序，它实际上是一个线程池，用于以给定的速率或延迟重复执行任务。它实际上是Timer/TimerTask组合的更通用替代品\n\n","tags":["源码阅读","Java"]}]