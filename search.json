[{"title":"《正则表达式》","url":"/2022/08/28/正则表达式/","content":"\n# 正则表达式\n\n今天来聊一聊让程序员又爱又恨的正则表达式\n\n## 简介\n\n正则表达式是一种进行模式匹配和文本操作的复杂而又强大的工具，虽然比固定字符匹配要慢，但是胜在灵活，本文中以`Go`做介绍\n\n## 语法规则\n\n### 字符\n\n| 语法     | 说明                                                         | 表达式示例 | 匹配结果          |\n| -------- | ------------------------------------------------------------ | ---------- | ----------------- |\n| 一般字符 | 匹配自身                                                     | abc        | abc               |\n| .        | 匹配任意除换行符\"\\n\"外的字符， 在 DOTALL 模式中也能匹配换行符 | a.c        | abc               |\n| \\        | 转义字符，使后一个字符改变原来的意思； 如果字符串中有字符 * 需要匹配，可以使用 \\* 或者字符集［*]。 | a\\.c a\\\\c  | a.c a\\c           |\n| [...]    | 字符集（字符类），对应的位置可以是字符集中任意字符。 字符集中的字符可以逐个列出，也可以给出范围，如 [abc] 或 [a-c]， 第一个字符如果是 ^ 则表示取反，如 [^abc] 表示除了abc之外的其他字符。 | a[bcd]e    | abe 或 ace 或 ade |\n| \\d       | 数字：[0-9]                                                  | a\\dc       | a1c               |\n| \\D       | 非数字：[^\\d]                                                | a\\Dc       | abc               |\n| \\s       | 空白字符：[<空格>\\t\\r\\n\\f\\v]                                 | a\\sc       | a c               |\n| \\S       | 非空白字符：[^\\s]                                            | a\\Sc       | abc               |\n| \\w       | 单词字符：[A-Za-z0-9]                                        | a\\wc       | abc               |\n| \\W       | 非单词字符：[^\\w]                                            | a\\Wc       | a c               |\n\n### 数量词\n\n| 语法  | 说明                                                         | 表达式示例 | 匹配结果     |\n| ----- | ------------------------------------------------------------ | ---------- | ------------ |\n| *     | 匹配前一个字符 0 或无限次                                    | abc*       | ab 或 abccc  |\n| +     | 匹配前一个字符 1 次或无限次                                  | abc+       | abc 或 abccc |\n| ?     | 匹配前一个字符 0 次或 1 次                                   | abc?       | ab 或 abc    |\n| {m}   | 匹配前一个字符 m 次                                          | ab{2}c     | abbc         |\n| {m,n} | 匹配前一个字符 m 至 n 次，m 和 n 可以省略，若省略 m，则匹配 0 至 n 次； 若省略 n，则匹配 m 至无限次 | ab{1,2}c   | abc 或 abbc  |\n\n### 边界匹配\n\n| 语法 | 说明                                         | 表达式示例 | 匹配结果 |\n| ---- | -------------------------------------------- | ---------- | -------- |\n| ^    | 匹配字符串开头，在多行模式中匹配每一行的开头 | ^abc       | abc      |\n| $    | 匹配字符串末尾，在多行模式中匹配每一行的末尾 | abc$       | abc      |\n| \\A   | 仅匹配字符串开头                             | \\Aabc      | abc      |\n| \\Z   | 仅匹配字符串末尾                             | abc\\Z      | abc      |\n| \\b   | 匹配 \\w 和 \\W 之间                           | a\\b!bc     | a!bc     |\n| \\B   | [^\\b]                                        | a\\Bbc      | abc      |\n\n### 特殊构造\n\n| 语法      | 说明                                                         | 表达式示例        | 匹配结果         |\n| --------- | ------------------------------------------------------------ | ----------------- | ---------------- |\n| (?:...)   | (…) 的不分组版本，用于使用 \"\\|\" 或后接数量词                 | (?:abc){2}        | abcabc           |\n| (?iLmsux) | iLmsux 中的每个字符代表一种匹配模式，只能用在正则表达式的开头，可选多个 | (?i)abc           | AbC              |\n| (?#...)   | # 后的内容将作为注释被忽略。                                 | abc(?#comment)123 | abc123           |\n| (?=...)   | 之后的字符串内容需要匹配表达式才能成功匹配                   | a(?=\\d)           | 后面是数字的 a   |\n| (?!...)   | 之后的字符串内容需要不匹配表达式才能成功匹配                 | a(?!\\d)           | 后面不是数字的 a |\n| (?<=...)  | 之前的字符串内容需要匹配表达式才能成功匹配                   | (?<=\\d)a          | 前面是数字的a    |\n| (?<!...)  | 之前的字符串内容需要不匹配表达式才能成功匹配                 | (?<!\\d)a          | 前面不是数字的a  |\n\n### Go演示\n\n```go\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tbuf := \"abc azc a7c aac 888 a9c tac\"\n\tregex := regexp.MustCompile(`a.c`)\n\tresutl := regex.FindAllStringSubmatch(buf, -1)\n\tfmt.Println(resutl)\n}\n```\n\n运行结果\n\n```go\n[[abc] [azc] [a7c] [aac] [a9c]]\n```\n","tags":["每天写点啥"]},{"title":"《Java流操作》——读书笔记","url":"/2022/08/10/Java流操作/","content":"\n# 从迭代到流的操作\n\n处理集合时，我们常常会遍历他们的元素，然后对其中的元素做一些操作，例如我们如果想从一个文件中读取一个字符串，然后用非字母对他们进行分割，我们一般会这么干\n\n```java\n        String contents = Files.readString(Paths.get(\"D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt\"));\n        // 非字母分隔符\n        List<String> words = Arrays.asList(contents.split(\"\\\\PL+\"));\n        System.out.println(words);\n        for (String word : words) {\n            System.out.println(word);\n        }\n```\n\n现在，我们可以尝试用流的操作替代循环\n\n```java\n        String contents = Files.readString(Paths.get(\"D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt\"));\n        // 非字母分隔符\n        List<String> words = Arrays.asList(contents.split(\"\\\\PL+\"));\n        System.out.println(words);\n//        for (String word : words) {\n//            System.out.println(word);\n//        }\n        long count1 = words.stream().filter(Objects::nonNull).count();\n        System.out.println(count1);\n```\n\n就像这样，这比循环更加简洁\n\n## stream和parallelStream\n\n在Java中，这两种都是流操作，但是它们两个有一些区别\n\n+ stream是串行流，也就是说stream流中的元素是一个一个顺序执行的\n+ 而parallelStream是并行流，可以以并行方式来进行过滤和计数\n\n至于并行流，在后面会详细介绍\n\n流操作表面上和集合是非常相似的，但是它们有着非常显著的差异：\n\n+ 流操作并不存储元素。这些元素储存在底层的集合中按需生成。\n+ 流操作并不会修改数据源，而是产生一个新的流\n+ 流的操作是尽可能惰性执行的。比如我们想要查找前五个长单词而不是所有长单词，那么流就会在匹配到第五个长单词时停止过滤，因此按理说我们可以操作无限流。\n\n## 章节总结\n\n流操作API：\n\n+ filter(Predicate<? super T> P)：产生一个流，其中包含所有满足P的元素\n+ count()：计算当前流中元素的数量\n\n流的种类：\n\n+ stream：串行流\n+ parallelStream：并行流\n\n# 流的创建\n\n我们已经知道用Collection类的stream方法可以将一个集合转化为流，当然，不止集合，数组也可以\n\n对于一个数组，我们可以使用Stream.of方法将数组转变为流\n\n```java\nint[] a = new int[]{1, 3, 5, 9, 1, 5, 6, 8};\nStream<int[]> a1 = Stream.of(a);\n```\n\nof方法用的是可变参数，所以我们可以传入任意长度的数组\n\n但是更加推荐Array.stream(array, from, to)方法，可以从数组的from到to创建一个流对象\n\n如果想产生一个空的流，可以使用`Stream.empty()`方法\n\n## 为什么推荐Array.stream\n\n对于对象类型的数组，Array.stream和Stream.of虽然有同样的返回，但是对于基本类型的数组，Stream.of.count返回的数组永远是1\n\n对于这点可以自行验证。\n\n## 无限流\n\n在Java8的流库中，有两个创建无限流的方法，generate和iterator\n\n详细可以从另一篇博客《Java流中的generate与iterator》了解\n\n### iterator\n\niterator需要我们传入两个参数，`seed`和`initial element seed`，一个是初始值，一个是产生无限流的依据\n\n```java\nStream<BigInteger> stream = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.TEN)).limit(100);\nSystem.out.println(Arrays.toString(stream.filter(n -> n.compareTo(new BigInteger(String.valueOf(170L))) < 0).toArray()));\n```\n\n### generate\n\ngenerate则需要我们传入一个Supplier对象，里面可以定义规则，比iterator更加灵活\n\n```java\nStream<Integer> stream1 = Stream.generate(new Supplier<Integer>() {\n            static int a = 0;\n\n            @Override\n            public Integer get() {\n                return a++;\n            }\n        }).limit(20);\n        System.out.println(Arrays.toString(stream1.toArray()));\n```\n\n或者说，generate可以根据多个元素制定规则，而iterator只能根据一个元素\n\n在Java中，产生流的方式还有很多，比如Pattern.splitStream()、Files.lines()\n\nPattern.splitStream可以根据正则表达式来分割字符串形成一个流\n\n```java\nPattern.complie(\"\\\\PL+\").splitAsStream(content)\n```\n\n而Files.lines(path)方法则可以返回一个包含文件中所有行的流\n\n```java\ntry(Stream<String> lines = Files.lines(path)){\n    // Process line\n}\n```\n\n\n\n## 章节总结\n\n操作流API：\n\n+ of(T... values)：根据给定数组产生一个流\n+ empty()：产生一个空的流\n+ generate()：产生一个无限流\n+ iterator()：产生一个无限流\n\njava.util.Arrays：\n\n+ stream(T[] Arrays, int start, int end)：根据数组创建一个流\n\njava.util.regex.Pattern：\n\n+ splitAsStream(CharSequence input)：根据input产生一个流\n\njava.nio.file.Files：\n\n+ stream(Path path, [Charset c])：将指定文件中的行转化为流，并且可以设置指定字符集\n\njava.util.function.Supplier：\n\n+ get()：提供一个值，用于产生无限流\n\n# filter、map和flatMap\n\n## filter\n\nfilter可以从一个流中转换出一个流，其中的元素遵循某种规则，可以在`filter()`括号中定义这个规则，比如\n\n```java\nList<String> words = ...;\nStream<String> longWords = wordList.stream().filter(w -> w.length > 12)\n```\n\n这样这个流中就会只包含长度大于12的单词\n\nfilter更像是从一个流中筛选元素，组成另一个流\n\n## map\n\n相比于filter，map虽然也是产生一个新的流，但是map是将原来的流中的元素进行转换，比如将words中的单词全部小写\n\n```java\nStream<String> words = wordList.stream().map(String::toLowerCase);\n```\n\n或者你可以自定义一个函数，如下\n\n```java\npackage 核心技术卷II.JavaSe8的流库.流方法;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * @author JiangLiu\n * @Date 2022/8/10 21:24:52\n * @description\n */\npublic class map {\n    public static void main(String[] args) {\n        List<String> words = new ArrayList<>();\n        words.add(\"Abc\");\n        words.add(\"Bcd\");\n        words.add(\"Java\");\n        words.add(\"GoLang\");\n        words.add(\"Rust\");\n        List<String> collect = words.stream().map(String::toLowerCase).collect(Collectors.toList());\n        System.out.println(collect);\n\n        List<List<String>> collect1 = words.stream().map(w -> myMap(w).collect(Collectors.toList())).collect(Collectors.toList());\n        System.out.println(collect1);\n\n    }\n\n    public static Stream<String> myMap(String s){\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++){\n            list.add(s.substring(i, i + 1));\n        }\n        return list.stream();\n    }\n}\n[abc, bcd, java, golang, rust]\n[[A, b, c], [B, c, d], [J, a, v, a], [G, o, L, a, n, g], [R, u, s, t]]\n```\n\n但是这样每个单词都是一个List，我们可能并不想出现这种情况，这时候flatMap方法就派上用场了\n\n## flatMap\n\nflatMap可以将当前流中的所有元素拼接到一起返回\n\n```java\nList<String> collect2 = words.stream().flatMap(w -> myMap(w)).collect(Collectors.toList());\n        System.out.println(collect2);\n[A, b, c, B, c, d, J, a, v, a, G, o, L, a, n, g, R, u, s, t]\n```\n\n返回一个流，其中包含将**该流的每个元素**替换为将提供的映射函数应用到每个元素所产生的映射流的内容的结果。每个被映射的流在其内容被放置到这个流之后被关闭。\n\n而map是单个元素\n\n## 章节总结\n\njava.util.Stream：\n\n+ filter：产生一个流，其中包含当前流中所有满足条件的元素\n+ map(Function<? super T> mapper)：产生一个流，其中包含将mapper应用于流中的每一个元素所产生的结果\n+ flatMap(Function mapper)：产生一个流，其中包含将mapper应用于流中每一个元素所产生的结果的组合\n\n# 抽取子流和连接流\n\n## 抽取流\n\n在介绍无限流的时候，有一个API叫`limit()`，这个API会产生一个新的流，并且在流运行到第n个元素时结束，对裁剪无限流非常好用\n\n```java\nList<Double> collect = Stream.generate(Math::random).limit(5).collect(Collectors.toList());\nSystem.out.println(collect);\n```\n\n这个流就只包含五个随机数\n\n而`stream.skip(long n)`API正好相反，这个API会在跳过前n个元素，对后面的元素进行截取。\n\n```java\nList<String> words = new ArrayList<>();\n        words.add(\"Abc\");\n        words.add(\"Bcd\");\n        words.add(\"Java\");\n        words.add(\"GoLang\");\n        words.add(\"Rust\");\n        List<String> collect1 = words.stream().skip(2).collect(Collectors.toList());\n        System.out.println(collect1);\n\n[Java, GoLang, Rust]\n```\n\n返回的流跳过了前两个元素\n\n## 连接流\n\n如果想要将两个Luis连接起来，可以使用`stream.contact(Stream a, Stream b)`将两个流进行连接\n\n```java\nList<Object> collect2 = Stream.concat(collect.stream(), collect1.stream()).collect(Collectors.toList());\n        System.out.println(collect2);\n\n[0.19283510014488758, 0.986608060762175, 0.07406377892420113, 0.6737128935974602, 0.5210312651857187, Java, GoLang, Rust]\n```\n\n## 章节总结\n\n本章一共介绍了三个API，两个抽取子流，一个拼接流\n\njava.util.Stream：\n\n+ limit(long maxSize)：抽取流中最初的maxSize个元素，并返回一个新的流\n+ skip(long n)：抽取流中除了前n个元素之前的元素，并返回一个新的流\n+ contact(Stream a, Stream b)：拼接两个流，并返回一个新的流\n\n# 其他流的转换\n\n`distinct()`函数能够帮助我们从一个流中返回一个新的流，并且没有重复元素\n\n```java\n/**\n * @author JiangLiu\n * @Date 2022/8/29 21:05:21\n * @description\n */\npublic class StreamTrans {\n    public static void main(String[] args) {\n        Stream<String> a = Stream.of(\"merrily\", \"merrily\", \"merrily\", \"gently\");\n        // 流只能使用一次！！！！\n//        System.out.println(Arrays.toString(a.toArray()));\n        System.out.println(Arrays.toString(a.distinct().toArray()));\n    }\n}\n```\n\n与数组一样，我们可以使用`sorted()`对流进行排序\n\n```java\nSystem.out.println(\"=========流排序========\");\n        String[] str = new String[]{\"Go\", \"Java\", \"C/C++\"};\n        Stream<String> str1 = Stream.of(str);\n        Object[] objects = str1.sorted(Comparator.comparing(String::length)).toArray();\n        System.out.println(Arrays.toString(objects));\n```\n\n当然，我们也可以使用数组进行排序，但是当排序方法是流管道的一部分时，sorted函数就显得非常有用\n\n最后还有一个`peek`函数，这个函数和`map`有一些类似，都是产生一个新的流，并且对元素进行一些处理，但是`map`是处理元素值，`peek`是执行函数\n\n```java\n        String[] str = new String[]{\"Go\", \"Java\", \"C/C++\"};\n\t\tSystem.out.println(\"=========peek========\");\n        Stream<String> str2 = Stream.of(str);\n        Stream<String> peek = str2.peek(System.out::println);\n        System.out.println(Arrays.toString(peek.toArray()));\n```\n\n这样就会将数组逐个输出。\n\n## 章节总结\n\n### java.util.stream.Stream\n\n+ Stream<T> distinct()：产生一个新的流，剔除当前流中的重复元素\n+ Stream<T> sorted()\n+ Stream<T> sorted(Comparator<? super T> comparator)：产生一个新的流并且进行排序\n+ Stream<T> peek(Consumer<? super T> action)：产生一个新的流，与当前元素相同，并且在获取其中每个元素时都会传递给action\n\n# 简单约简\n\n我们已经看到了如何创建和转换流，终于可以来一点有意思的东西了：从数据流中获取答案，这种方法被称为约简。这是一种`终结操作`，他们**会将流约简成可以在程序中使用的非流值**。\n\n之前我们已经使用过`count`，这就是一种简单约简，同样的还有`max`和`min`，这些方法的返回值是一个`Optional<T>`，它会在其中包装答案，或者什么都不做（流值为空），在以前这种操作容易造成空指针异常，在下一节中我们会详细讨论。\n\n```java\npublic static void main(String[] args) {\n        String[] words = new String[]{\"Go\", \"Java\", \"C/C++\", \"Rust\"};\n        Stream<String> words1 = Stream.of(words);\n        Optional<String> max = words1.max(String::compareToIgnoreCase);\n        System.out.println(max);\n    }\n```\n\n这个方法展示了如何获取流的最大值，但是结果和我们想象的不太一样\n\n`Optional[Rust]`\n\n还有找到第一个以G开头的单词\n\n```java\nSystem.out.println(\"=====findFirst====\");\nOptional<String> g = Stream.of(words).filter(e -> e.startsWith(\"G\")).findFirst();\nSystem.out.println(g);\n```\n\n如果不强制匹配第一个，那么可以使用`findAny`，这个方法在处理并行流时很有效\n\n或者只是想知道有没有存在某个值符合，可以使用`anyMatch`来进行匹配，这个函数会返回一个boolean，而不是具体的值，同时，这个方法需要接受一个断言引元，而不是filter，就像这样\n\n```java\nboolean g2 = Stream.of(words).anyMatch(e -> e.startsWith(\"G\"));\nSystem.out.println(g2);\n```\n\n\n\n还有`allMatch`和`noneMatch`，分别会在全部符合或者没有符合时返回`true`\n\n## 章节总结\n\n### java.util.stream.Stream\n\n+ Optional<T> max(Comparator<? super T> comparator)\n+ Optional<T> min(Comparator<? super T> comparator)：这两个方法分别会返回最大元素和最小远古三\n+ Optional<T> findFirst()\n+ Optional<T> findAny()：分别产生这个流的第一个元素和任意一个元素\n+ Optional<T> anyMatch(Predicate<? super T> predicate)\n+ Optional<T> allMatch(Predicate<? super T> predicate)\n+ Optional<T> noneMatch(Predicate<? super T> predicate)：分别在这个流中任意元素、所有元素和没有任何元素匹配时返回`true`\n\n# Optional类型\n\n上一节中我们使用到了这个对象，这节来自习介绍一下\n\nOptional类型是一种包装器对象，要么包装了类型T的对象，要么没有包装任何对象，用于解决空指针异常问题。\n\n## 如何使用\n\nOptional是一个很好用的东西，如果值不存在的状态下，它会自动产生一个替代的值\n\n第一种情况：\n\n如果某个值不存在，我们想要用一个空字符串去代替他\n\n```java\nString s = a.orElse(\"\");\nSystem.out.println(s);\n```\n\n或者调用一个方法去计算\n\n```java\ns = a.orElseGet(() -> {\n    return String.valueOf(System.currentTimeMillis());\n});\nSystem.out.println(s);\n```\n\n又或者是抛出一个异常\n\n```java\nString s1 = a.orElseThrow(IllegalAccessError::new);\n```\n\n这些方法在不存在任何值时会产生一个相应的替代物；还有一个函数可以选择只有在值存在的情况下才进行消费。\n\n`ifPresent`只会在值存在的情况下才会接受一个函数，否则不会发生任何事情。\n\n```java\nOptional<String> b = Optional.of(\"123\");\nb.ifPresent(System.out::println);\n```\n\n当我们调用`isPresent`时，这个函数不会返回任何值，如果想要获取处理的结果，可以使用`map`\n\n```java\nList<String> result = new ArrayList<>();\nOptional<Boolean> aBoolean = b.map(result::add);\nSystem.out.println(aBoolean);\n```\n\n**注意**：这里的aBoolean有三种值，`true`和`false`所对应的Option，和空值所对应的Option\n\n### 总结\n\n#### java.util.Optional\n\n+ T orElsr(T other)：产生这个Optional的值，在值为空时，返回other\n+ T orElseGet(Supplier<? extends T> other)：产生这个Optional的值，在值为空时，返回other这个**方法**所返回的结果\n+ <X extends Throwable> T orElseThrow(Supplier<? extends X> action)：返回Optional的值，值为空时，抛出action返回的结果\n+ void isPresent(Consumer<? super T> consumer)：如果值不为空，就将值传递给consumer这个**方法** \n+ <U> Optional<U> map(Function<? super T, ?extends U> mapper)：将值传递给mapper并产生返回结果，如果值为空，返回也是一个空Optional\n\n## 不适合使用Optional值的方式\n\n如果没有正确使用Optional的值，那么相比较其他获得`null`的方式，并没有任何区别。\n\n`get`方法会在Optional值存在IDE情况下获得其中包装的元素，或者在不存在的情况下抛出一个`NoSuchElementException`对象，所以\n\n```java\nOptional<T> optional = ...;\noptional.get().method();\n```\n\n```java\nT a = new T();\na.method();\n```\n\n以上两种用法并没有太大区别。\n\n```java\nOptional<T> optional = ...;\nif (optional.isPresent()){\n    optional.get().method()\n}\n```\n\n```java\nT value = ...;\nif (value != null) value.method();\n```\n\n这两种方法也没有什么区别\n\n### 总结\n\n#### java.util.Optional\n\n+ T get()：产生这个Optional的值，或者在值为空时，抛出一个`NoSuchElementException`异常\n+ boolean isPresent()：如果值不为空，返回true\n\n## 创建Optional值\n\n现在我们已经知道了如何使用Optional值，但是对于如何创建我们一无所知\n\n有多个方法可以用于创建Optional，例如：\n\n+ Optional.of(T value)\n+ Optional.empty()\n\n或者如果不确定有没有这个value，也可以使用`Optional.ofNullable(T value)`，这个函数会根据value是否存在去调用`Optional.empty`或是`Optional.of()`\n\n### 总结\n\n#### java.util.Optional\n\n+ static <T> Optional<T> of(T value)\n+ static <T> Optional<T> empty()：产生一格具有给定值的Optional，如果值为空，of会抛出一个NullPointerException异常，empty会返回一个空Optional\n+ static <T> Optional<T> ofNullable(T value)：如果value存在调用of，不存在调用empty\n\n## 用flatMap构建Optional值的函数\n\n考虑这样一种场景，你有一个能够生成`Optional<T>`对象的方法`f`，`T`又有一个能够返回`Optional<U>`的方法`g`，如果想要通过f方法创建`Optional<U>`对象，可以使用\n\n```java\nOptional<U> result = s.f().flatMap(T::g);\n```\n\n如果`s.f()`的值存在，那么`g`就可以应用到它上面，否则会产生一个空Optional\n\n通过这种方式我们可以疯狂使用`flatMap`构建Optional，从而构建由这些步骤组成的管道，当所有步骤成功时，该管道才会成功\n\n在之前我们见过`Stream.flatMap()`，但是这里的flatMap和stream的不太一样。\n\n### 总结\n\n#### java.util.Optional\n\n+ <U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)：产生将mapper应用于当前的Optional值所产生的结果，或者在当前Optional为空时，返回一个空Optional\n\n# 收集结果\n\n当处理完流之后，如果想要查看其中的元素，我们可以使用`iterator`迭代器，或者`foreach`将某个函数应用到流中的每一个元素上去。\n\n当然，在并行流上`foreach`方法会导致访问顺序不一致，如果想要按照流原来的顺序进行访问，需要使用`forEachOrderd`方法，同时这个方法也会丧失并行流的部分甚至全部优势。\n\n或者我们可以将流转化为Array类型。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java流"]},{"title":"《Go随机数》——学习笔记","url":"/2022/08/09/go随机数/","content":"\n在GO语言中，提供了随机数的核心方法`rand`，但是go的随机数其实并不随机，是一个伪随机数，简单来说就是Go的随机数生成需要依赖种子值，对于相同的种子值产生的随机数顺序是相同的\n\n为了产生一个随机数，我们需要给rand设置一个不重复种子，最好的选择当然就是时间\n\n```java\nrand.Seed(time.Now().UnixNano())\n```\n\n**注意**：Seed接收的是一个int64类型的数字，需要用Unix将time转换成int64类型\n\n然后就可以使用rand.Intn(max int64)来进行取随机数了\n\n```java\nrand.Seed(time.Now().UnixNano())\nrandomInt := int64(rand.Intn(100))\nfmt.Println(randomInt)\n```\n\n","tags":["GoLang"]},{"title":"《Java序列化与反序列化》","url":"/2022/08/04/序列化与反序列化/","content":"\n这是一个新的系列，每天写一点自己的想法。\n\n\n\n突然想起来之前在面试的时候，面试官问过我这么一个问题：Java中创建类实例有哪几种方法\n\n+ new\n+ Java反射的newInstance\n+ clone\n+ 反序列化\n\n然后面试官又问我：反序列化你用过吗\n\n我就答不上来了，只知道有这个概念，具体怎么实现还真没去看过，今天来试一试\n\n## 编写实体类\n\n这里随便来写一个，但是记得实现序列化接口`Serializable`，没啥技术含量\n\n```java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n/**\n * @author JiangLiu\n * @Date 2022/8/4 15:38:24\n * @description 需要序列化的对象\n */\n@Data\n@AllArgsConstructor\npublic class People implements Serializable {\n    private String name;\n    private int age;\n}\n```\n\n## 编写序列化类\n\n这里主要用到的就是IO流，反序列化的处理可能不是那么妥当，但是又一直报警告，明天再处理一下\n\n```java\nimport java.io.*;\n\n/**\n * @author JiangLiu\n * @Date 2022/8/4 15:39:56\n * @description\n */\npublic class SerializableUtil<T> {\n\n    /**\n     * 序列化\n     */\n    public void serialize(T obj, String fileName) throws IOException {\n        OutputStream out = new FileOutputStream(fileName);\n        ObjectOutputStream outputStream = new ObjectOutputStream(out);\n        outputStream.writeObject(obj);\n        // 用完记得关闭\n        outputStream.close();\n    }\n\n    /**\n     * 反序列化\n     */\n    public T deSerialize(String fileName) throws IOException, ClassNotFoundException {\n        InputStream in = new FileInputStream(fileName);\n        ObjectInputStream inputStream = new ObjectInputStream(in);\n        Object a = null;\n        a = inputStream.readObject();\n        return (T) a;\n    }\n}\n```\n\n## 编写main方法\n\n```java\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author JiangLiu\n * @Date 2022/8/4 15:38:06\n * @description\n */\npublic class main {\n    public static void main(String[] args) {\n        // 造几个People\n        List<People> people = new ArrayList<>();\n        people.add(new People(\"张三\", 15));\n        people.add(new People(\"李四\", 18));\n        String fileName = \"test.txt\";\n        SerializableUtil<List<People>> s = new SerializableUtil<>();\n        // 对象序列化\n        try {\n            s.serialize(people, fileName);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        // 反序列化\n        List<People> list = null;\n        try {\n            list = s.deSerialize(fileName);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(list);\n    }\n}\n```\n\n## 运行结果\n\n```tex\n[People(name=张三, age=15), People(name=李四, age=18)]\n```\n\n完美","tags":["每天写点啥"]},{"title":"《Redis实现客户端缓存》","url":"/2022/07/31/redis实现客户端缓存/","content":"\n在redis中，客户端缓存支持又被成为跟踪，有两种实现模式：\n\n+ 在默认模式下，服务器会记住给定客户端访问的键，并且在相同的键被修改时发送无效信息。这将占用服务器端内存，但是只会为客户端内存中可能存在的一组键发送无效信息\n+ 在广播模式下，服务器不会试图记住给定客户端访问的键，因此这种模式在服务器客户端不消耗任何内存。而客户端通过订阅前缀如`object:`或`user:`，并在键匹配订阅前缀是接收通知消息\n\n# 默认模式","tags":["Redis"]},{"title":"《RabbitMQ学习笔记》——读书笔记","url":"/2022/07/27/RabbitMQ学习笔记/","content":"\n# 什么是MQ\n\nMQ是`Message Queue`的简称，就是一个消息队列，队列嘛，FIFO先进先出，与普通队列的区别就是，MQ中存放的是消息，并且它是一种跨进程的通信机制，用于上下游传递消息，能够实现上下游之间的解耦\n\n# MQ在SpringBoot中的配置\n\n```yaml\nspring:\n\trabbitmq:\n\t\thost: // rabbitmq的地址\n\t\tport: // mq的端口\n\t\tusername: // mq的用户名\n\t\tpassword: // mq的密码\n\t\tvirtual-host: // 虚拟消息服务器\n\t\tpublisher-confirms: // 是否开启发送确认\n\t\tpublisher-returns: // 是否开启发送失败退回\n\t\ttemplate:\n\t\t\tmandatory: // 生产者是否启用强制消息\n\t\t\tretry:\n\t\t\t\tenable: // 生产者是否开启重启\n\t\tlistener:\n\t\t\tacknowledge-mode: // 消费者ack模式\n\t\t\tretry:\n\t\t\t\tenable: // 消费者是否重试\n\t\t\t\tmax-attempts: // 消费者重试次数\n```\n\n## 配置详解\n\n### virtual-host\n\n`virtualHost`虚拟消息服务器，每个virtualHost相当于一个独立的MQ服务器，每个VirtualHost之间消息是隔离的，exchange、queue、message不能互通\n\n### publisher-confirms\n\n这个配置是为了在MQ和生产者之间的消息能够可靠传输，是MQ的扩展\n\n生产者推送消息到消息队列后，会触发两个回调函数`ConfirmCallback`和`ReturnCallback`，从消息推送的结果来看，一共有四种组合：\n\n+ 消息推送到server，但是在server里找不到交换机\n+ 消息推送到server，找到了交换机但是找不到队列\n+ 消息推送到server了，交换机和队列都没找到\n+ 消息推送成功\n\n生产者和消费者确认详见后文\n\n\n\n\n\n\n\n# 生产者和消费者确认\n\n由于MQ的传输协议方法无法确认生产者和消费者是否成功发布或者消费信息，所以生产者和消费者都需要一种传递和处理确认的机制\n\n## 消费者确认\n\n### 自动ACK\n\n在MQ中有一种自动确认模式机制，消息发送成功后立即被视为传递成功，这种模式以更高的吞吐量来降低交付和消费者处理的安全性为代价，如果消费者的TCP连接或通道在消息发送成功之前关闭，那么消息就会丢失，所以这种方法被视为是不安全的。\n\n在这个模式中，当方法没有异常执行完毕后，会对MQ发出ACK，若方法出现异常，会对MQ发出nack，消息重回队列。\n\n### 手动ACK\n\n常用API：\n\n+ channel.basicAck(msg.getMessageProperties().getDeliveryTag(), false/true)\n  + 消息确认，第一个参数是队列名称，第二个参数是multiple\n    + multiple：是否一次性ack所有deleveryTag的消息\n+ channel.basicReject(deleveryTag, requeue)\n  + 拒绝消息\n    + requeue：bool类型，false表示将这条消息丢弃，true表示消息重回队列\n+ channel.basicNack(deliveryTag, multiple, requeue)\n  + 拒绝消息\n    + deliveryTag：队列名称\n    + multiple：是否拒绝deliveryTag的所有消息\n    + requeue：是否返回队列\n","tags":["读书笔记","SpringBoot","RabbitMQ"]},{"title":"《Java流中的generate与iterator》——读书笔记","url":"/2022/07/26/stream中的generate与iterator/","content":"\n# Java流中的generate与iterator\n\n在Java流中，有两个创建无限流的方法：\n\n+ stream().generate()\n+ stream().iterator()\n\n## iterator\n\n从源码中给的解释来看\n\n```tex\nReturns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.\nThe first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.\nThe action of applying f for one element happens-before the action of applying f for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.\n形参:\nseed – the initial element f – a function to be applied to the previous element to produce a new element\n返回值:\na new sequential Stream\n```\n\niterator创建的无限流是根据`seed`与`initial element seed`来创建的，简单来说就是一个起始元素seed，一个创建的规则\n\n```java\nStream<BigInteger> stream = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE)).limit(10);\n        System.out.println(Arrays.toString(stream.filter(n -> n.compareTo(new BigInteger(String.valueOf(1794952398L))) < 0).toArray()));\n```\n\n这里用limit来限制一下产生的无限流，否则无法正常输出\n\n## generate\n\n同样还是来看源码中给的解释\n\n```tex\nReturns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.\n形参:\ns – the Supplier of generated elements\n返回值:\na new infinite sequential unordered Stream\n```\n\n对于generate来说，只提供给我们一个参数`Supplier`，翻译过来叫 供应商，里面存放着产生供应流的规则\n\n```java\nStream<Integer> stream1 = Stream.generate(new Supplier<Integer>() {\n            static int a = 0;\n\n            @Override\n            public Integer get() {\n                return a++;\n            }\n        }).limit(20);\n        System.out.println(Arrays.toString(stream1.toArray()));\n```\n\n这里同样用limit限制一下\n\n至于具体的使用场景，后续会继续更新\n","tags":["Java","Java流"]},{"title":"《MyBatis 和 MyBatis Plus冲突问题》——解决模块","url":"/2022/07/25/mybatisplus和mybatis冲突问题/","content":"\n# 问题\n\n在工作的时候，遇到了一个奇怪的问题，使用 MyBatis Plus 的IService模板中的list对数据库进行操作时，报了个`Invalid bound statement (not found)`\n\n# 解决\n\n搜了半天，主要是以下几个问题：\n\n+ xml 的 namespace 不正确\n+ Mapper.java 中的方法在 Mapper.xml 中不存在\n+ xml 返回类型配置错误\n+ 没有构建成功\n\n但是这些问题都检查了，没问题，用 Maven Helper 查看了一下依赖冲突，看到项目中同时引入了mybatis和mybatisplus，具体冲突的包有三个：\n\n+ mapper-spring-boot-starter\n+ mybatis-spring-boot-starter\n+ mybatis-plus-extension\n\n首先，`mybatis-spring-boot-starter`包是用来连接mybatis和springboot的中间件，这个 mybatis-plus-boot-starter能够代替，冲突了，去掉\n\n然后是 `mapper-spring-boot-starter`包，这个包是用来导入公共mapper模板的，具体作用暂时不知道，但是不去掉也不能运行\n\n最后是`mybatis-plus-extension`，这个东西具体作用没查到，只知道他是mybatisplus的扩展插件，但是去掉之后service层的函数全都无法调用了\n\n","tags":["MyBatis Plus","SpringBoot","问题解决"]},{"title":"《Java常用注解》","url":"/2022/07/15/java常用注解/","content":"\n# @PostConstruct\n\n从Java EE 5 之后，Servlet增加了两个影响Servlet生命周期的注解：\n\n+ @PostConstruct\n+ @PreConstruct\n\n## @PostConstruct\n\n被这个注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，被PostConstruct修饰的方法会在构造函数之后，init之前运行\n\n## @PreConstruct\n\n被这个注解修饰的方法会在服务器卸载Servlet的时候运行，并且只会调用一次，类似于destroy","tags":["Java","注解"]},{"title":"《lambda表达式的语法》——读书笔记","url":"/2022/07/15/lambda表达式/","content":"\n# lambda表达式的语法\n\n了解过javax.swing.Timer函数和Comparator比较器的可以发现，这两个例子有一些共同点，都是将某一段代码块传到某个对象，如果可以直接传入一段代码块，那代码会变得非常简洁，但是Java并不支持这种方法，因为这会让Java语言变得一团糟\n\n在 java 8 后，加入了lambda表达式，这是一个可传递的代码块,可以让某个接口不写实现类而直接使用\n\nnew Timer中需要传入一个ActionListener接口，实际上只是调用这个接口中的actionPerformed函数，Comparator也是同理\n\n案例：\n\n```java\npublic class lambdaTest {\n    public static void main(String[] args) {\n        String[] a = new String[]{ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" ,\n                \"Jupiter\" , \"Saturn\" , \"Uranus\" , \"Neptune\"};\n        Arrays.sort(a, (left, right) -> {\n            return left.length() - right.length();\n        });\n        System.out.println(a);\n\n        Timer t = new Timer(100, event ->{\n            System.out.println(new Date());\n        });\n        t.start();\n        JOptionPane.showMessageDialog(null, \"Quit\");\n        System.exit(0);\n    }\n}\n```\n\n# 函数式接口\n\nJava中已经有了很多封装代码块地接口，如AactionListener、Comparator，lambda与这些接口是兼容的\n\n对于只有一个抽象方法的接口，需要用到这种接口的对象时，可以使用lambda表达式，这种接口成为函数式接口\n\n+ 为什么Comparator接口也能成为函数式接口，明明有compare、equals两个抽象函数\n  + 对于接口重写Object的公共方法是不算入函数式接口中的，也就是说Comparator只有compare一个非公共抽象函数\n\n以Arrays.sort为例，在底层，sort方法会接收Comparator的某个类的对象，在这个对象上再调用compare方法执行lambda表达式的方法体。\n\nlambda表达式可以转换成接口\n\n```java\nTimer t = new Timer(100, event ->{\n    System.out.println(new Date());\n});\n```\n\n与原来的写法相比，这个可读性要高得多\n\n实际上在Java中 lambda 表达式的作用非常有限，也只能转换为函数式接口，在其他语言中，可以声明函数类型、声明这些类型的变量，还可以使用变量保存函数表达式。\n\n# 方法引用\n\n有时候我们希望可已经有现成的方法可以完成你想要传递到其他代码的某个动作，比如希望定时器事件打印这个事件对象\n\n```java\nTimer t = new Timer(1000, event -> System.out.println(event)):\n```\n\n但是入股哟能直接把print方法传递到Timer构造器就更简洁了，lambda\n\n表达式也能够做到\n\n```java\nTimer t = new Timer(100, System.out::println);\n```\n\n![image-20220720173122252](/img/image-20220720173122252.png)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","读书笔记"]},{"title":"《MybatisPlus 常用注解》","url":"/2022/07/15/mybatisplus常用注解/","content":"\n\n\n# @TableName\n\n用法\n\n```java\n@TableName(\"sys_user\")\n```\n\n描述：表名注解，标识实体类对应表\n\n使用位置：实体类类注解\n\n属性：\n\n+ value：表名\n+ schema：用来指定模式名称，如果使用的是mysql，则指定数据库名称，如果使用oracle，则为schema\n+ keepGlobalPrefix：是否保持使用全局的tablePrefix的值\n+ resultMap：xml中resultMap的id\n+ autoResultMap：是否自动构建ResultMap\n+ excludeProperty：需要排除的属性名\n\n# @TableId\n\n用法\n\n```java\n@TableId(value=\"user_id\", type=IdType.ASSIGN_UUID)\n```\n\n 描述：主键属性\n\n使用位置：实体类主键字段\n\n属性：\n\n+ value：主键字段名\n+ type：指定主键类型\n\n## Type属性值\n\n+ AUTO：数据库ID自增\n+ NONE：无状态，未设置主键类型（跟随全局，全局默认为INPUT）\n+ INPUT：insert前自行设置\n+ ASSIGN_ID：分配ID，使用接口`IdentifierGenerator`的`nextId`，实现类默认为雪花算法\n+ ASSIGN_UUID：分配UUID\n\n## @TableField\n\n用法\n\n```java\n@TableName(\"sys_user\")\npublic class User {\n    @TableId\n    private Long id;\n    @TableField(\"nickname\")\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n描述：字段注解（非主键）\n\n属性：\n\n+ value：数据库字段名\n+ exist：是否为数据库字段\n\n","tags":["注解","Mybatis Plus"]},{"title":"《事务传播行为》","url":"/2022/07/15/事务传播行为/","content":"\n# 什么是事务传播行为\n\n我们在Spring中使用事务时，经常会在一个事务中调用另外一个事务，这种事务嵌套的控制方式就是事务传播行为\n\n# 事务传播行为的七种方式\n\n+ propagation_required\n  + 事务传播的默认形式，如果当前没有事务，就新建一个事务，如果已经存在事务，就加入到这个事务中\n+ propagation_supports\n  + 支持当前事务，如果当前没有事务，就以非事务方式执行\n+ propagation_mandatory\n  + 使用当前事务，如果当前没有事务，就抛出异常\n+ propagation_requires_new\n  + 新建事务，如果当前存在事务，就把当前事务挂起\n+ propagation_not_supported\n  + 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n+ propagation_never\n  + 以非事务方式执行，如果当前存在事务，就抛出异常\n+ propagation_nested\n  + 如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行propagation_required类似的操作\n\n\n\n总结\n\n如果事务嵌套，子事务回滚，如果子事务没有将父事务挂起，父事务也会回滚，不管父事务中是否有对子事务进行异常捕获","tags":["SpringBoot","事务","MySQL"]},{"title":"《事务失效》","url":"/2022/07/15/事务失效的几种情况与原因/","content":"\n# 事务失效的几种情况与原因\n\n+ service没有托管给spring\n+ 抛出受检异常\n+ 业务自己捕获了异常\n+ 切面顺序导致\n+ 非public方法\n+ 父子容器\n+ 方法被final修饰\n+ 方法被static修饰\n+ 调用本类方法\n+ 多线程调用\n+ 错误的传播行为\n+ 使用了不支持事务的存储引擎\n+ 数据源没有配置事务管理器\n+ 被代理的类过早实例化\n\n## service没有托管给spring\n\n事务的前提是service必须是一个bean对象\n\n## 抛出受检异常\n\nspring默认回滚的是runtimeException，如果要触发其他异常的回滚，可以通过rollbackFor进行配置\n\n## 业务自己捕获了异常\n\nspring只有捕捉到了业务抛出的异常时，才会进行后续处理，如果业务自己捕获了异常并进行处理，事务无法感知\n\n## 切面顺序导致\n\n![image-20220713172742115](/img/image-20220713172742115.png)\n\n因为spring事务本质上也是一个切面，自定义切面捕捉到了异常但是没有往外抛出，事务切面捕获不到异常\n\n## 非public方法\n\nspring事务默认生效的方法权限都必须为public\n\n解决办法：\n\n+ 修改方法为public\n+ 修改TransactionAttributeSource，将publicMethodsOnly修改为false\n+ 开启AspectJ代理\n\n## 父子容器\n\n原因：子容器扫描范围过大，将未加事务配置的service扫描进来\n\n这个一般用于spring整合springmvc中，springboot没有父子容器\n\n## 方法用final修饰\n\nspring事务是用动态代理实现的，如果方法使用了final修饰，代理类无法对目标类进行重写，就无法实现事务\n\n## 方法用static修饰\n\n原因和final一样\n\n## 调用本类方法\n\n调用本类方法不经过代理，就无法进行增强\n\n## 多线程调用\n\n原因：spring的事务是通过数据库连接来实现的，而数据库连接spring是放在threadLocal里面的，同一个事务只能用同一个数据库连接。而多线程场景下，拿到的数据库连接不同，即属于不同事务\n\n## 错误的传播行为\n\n详情看  事务传播行为\n\n## 使用了不支持事务的存储引擎\n\n比如mysql中的MyISAM就不支持事务\n\n## 数据源没有配置事务管理器\n\nspringboot中默认开启事务管理器\n\n## 被代理的类被过早实例化\n\n具体应该要看源码","tags":["SpringBoot","事务","MySQL"]},{"title":"《常用类与接口》","url":"/2022/07/15/常用类与接口/","content":"\n# Comparator接口\n\n遇到的问题：在开发中需要对一个含有实体类的泛型数组进行排序\n\ncomparator接口可以实现这个功能\n\n简单用法：\n\n```java\npublic class Collections_ {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        list.add(\"tom\");\n        list.add(\"smith\");\n        list.add(\"king\");\n        list.add(\"king\");\n        list.add(\"king\");\n        list.add(\"milan\");\n\n        Collections.sort(list, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 instanceof String && o2 instanceof String){\n                    return (((String) o1).length() - ((String) o2).length());\n                }\n                return 0;\n            }\n        });\n        System.out.println(list);\n    }\n}\n```\n\n# Cloneable接口\n\n克隆接口，这个接口中提供了一个安全的clone方法\n\n# DefaultIdentifierGenerator类\n\n位于`com.baomidou.mybatisplus.core`包中，用于生成雪花算法ID\n\n```java\nlong id = new DefaultIdentifierFenerator().nextId(new Objec);\n```\n\n\n\n","tags":["Java"]},{"title":"《SpringBoot常用注解》","url":"/2022/07/15/SpringBoot常用注解/","content":"\n# Springboot常用注解\n\n+ Value：属性赋值\n+ Component：与业务层、dao层、控制层不相关的类需要在spring容器中创建使用\n+ Mapper：注解当前类为mapper类\n+ MapperScan：如果想要每个接口都变成实现类，那么需要在每个接口上添加Mapper注解，比较麻烦，可以使用MapperScan进行扫描\n+ Service：表示当前层为Service层\n+ Controller：控制层对象的创建\n+ RestController：Controller与ResponseBody的结合，让当前类下web请求返回数据而不是视图\n+ Autowired：根据类型自动注入\n+ Resouce：根据名称自动注入\n\n## @SpringBootApplication注解\n\n这个注解包含了三个注解，分别是：\n\n@SpringBootConfiguration：自动扫描添加了@Configuration注解的类，读取其中的配置信息\n\n@EnableAutoConfiguration：开启自动配置告诉Springboot基于所添加的依赖去猜测你想要如何配置spring，比如说我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖，此时自动配置就只要你是要开发一个web应用，就会帮我们去完成web以及springMVC的默认配置。\n\n@ComponentScan：配置组件扫描\n\n## @Transaction\n\n事务注解\n\n### 失效场景\n\n具体看我的另一篇博客——《事务失效》\n\n## @EnableScheduling\n\n开启定时任务，配合@Schedule注解使用，使这个注解功能可用\n\n## @Bean\n\n告诉方法产生一个bean对象，然后将这个bean交给spring进行管理，在产生bean的时候这个方法会调用一次，然后将产生的bean对象放入spring容器中\n\n## @PostConstruct\n\n在spring中，有一个接口叫`InitializationBean`，这个接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，并且在这个接口中有一个定义好的初始化方法`afterPropertiesSet`\n\n**但是**，spring并不推荐使用这种方法来调用初始化，它会将不必要的代码耦合到spring\n\n相比于`InitializationBean`，spring更推荐我们使用`@PostConstruct`注解\n\n至于为什么推荐使用`@PostConstruct`：\n\n+ InitializationBean是直接执行方法来进行初始化的，会耦合进Spring项目\n+ @PostConstruct注解是通过反射机制来初始化的\n\n## @ConfigurationProperties\n\n在SpringBoot中，如果我们想要获取到配置文件中某个属性的值，有两个方法：\n\n+ @Value\n+ @ConfigurationProperties\n\n这里我们只介绍第二个\n\n```yaml\nconfig:\n\tusername: JiangLiu\n\tpassword: 123\n```\n\n如果我们想要获取username，只需要这样\n\n```java\n\n@Component\n@ConfigurationProperties(prefix = \"config\")\npublic class TestBean{\n \n    private String username;\n    \n    private String password;\n}\n```\n\n## @Qualifier\n\n`@Autowired`注解可以帮助我们进行spring依赖注入，但是很多场景下只用这个注解，spring并不知道我们需要注入哪个bean，比如B、C两个类同时继承A接口，这时我们注入A，spring就会抛出`NoUniqueBeanDefinitionException`异常，这时就需要使用@Qualifier注解\n","tags":["注解","SpringBoot"]}]