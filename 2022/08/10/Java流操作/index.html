<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="江流的博客">
    <meta property="og:type" content="website">
    <meta name="description" content="江流的博客">
    <meta name="keyword"  content="江流的博客，Java开发">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        《Java流操作》——读书笔记 - JiangLiu 日常
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="江流的个人博客" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 一名落魄的Java程序员 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>JiangLiu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E8%BF%AD%E4%BB%A3%E5%88%B0%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">从迭代到流的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream%E5%92%8CparallelStream"><span class="toc-text">stream和parallelStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">流的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90Array-stream"><span class="toc-text">为什么推荐Array.stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E6%B5%81"><span class="toc-text">无限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator"><span class="toc-text">iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generate"><span class="toc-text">generate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-1"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#filter%E3%80%81map%E5%92%8CflatMap"><span class="toc-text">filter、map和flatMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flatMap"><span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-2"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%AD%90%E6%B5%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B5%81"><span class="toc-text">抽取子流和连接流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E6%B5%81"><span class="toc-text">抽取流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B5%81"><span class="toc-text">连接流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-3"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">其他流的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-4"><span class="toc-text">章节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-Stream"><span class="toc-text">java.util.stream.Stream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BA%A6%E7%AE%80"><span class="toc-text">简单约简</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-5"><span class="toc-text">章节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-Stream-1"><span class="toc-text">java.util.stream.Stream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional%E7%B1%BB%E5%9E%8B"><span class="toc-text">Optional类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8Optional%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">不适合使用Optional值的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-1"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAOptional%E5%80%BC"><span class="toc-text">创建Optional值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-2"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8flatMap%E6%9E%84%E5%BB%BAOptional%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">用flatMap构建Optional值的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-3"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%9C"><span class="toc-text">收集结果</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 一名落魄的Java程序员 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        《Java流操作》——读书笔记
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2022-08-10 00:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Java" title="Java">Java</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#Java流" title="Java流">Java流</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h1><p>处理集合时，我们常常会遍历他们的元素，然后对其中的元素做一些操作，例如我们如果想从一个文件中读取一个字符串，然后用非字母对他们进行分割，我们一般会这么干</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 非字母分隔符</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">System.out.println(words);</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以尝试用流的操作替代循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 非字母分隔符</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">        System.out.println(words);</span><br><span class="line"><span class="comment">//        for (String word : words) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(word);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">long</span> count1 = words.stream().filter(Objects::nonNull).count();</span><br><span class="line">        System.out.println(count1);</span><br></pre></td></tr></table></figure>

<p>就像这样，这比循环更加简洁</p>
<h2 id="stream和parallelStream"><a href="#stream和parallelStream" class="headerlink" title="stream和parallelStream"></a>stream和parallelStream</h2><p>在Java中，这两种都是流操作，但是它们两个有一些区别</p>
<ul>
<li>stream是串行流，也就是说stream流中的元素是一个一个顺序执行的</li>
<li>而parallelStream是并行流，可以以并行方式来进行过滤和计数</li>
</ul>
<p>至于并行流，在后面会详细介绍</p>
<p>流操作表面上和集合是非常相似的，但是它们有着非常显著的差异：</p>
<ul>
<li>流操作并不存储元素。这些元素储存在底层的集合中按需生成。</li>
<li>流操作并不会修改数据源，而是产生一个新的流</li>
<li>流的操作是尽可能惰性执行的。比如我们想要查找前五个长单词而不是所有长单词，那么流就会在匹配到第五个长单词时停止过滤，因此按理说我们可以操作无限流。</li>
</ul>
<h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><p>流操作API：</p>
<ul>
<li>filter(Predicate&lt;? super T&gt; P)：产生一个流，其中包含所有满足P的元素</li>
<li>count()：计算当前流中元素的数量</li>
</ul>
<p>流的种类：</p>
<ul>
<li>stream：串行流</li>
<li>parallelStream：并行流</li>
</ul>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><p>我们已经知道用Collection类的stream方法可以将一个集合转化为流，当然，不止集合，数组也可以</p>
<p>对于一个数组，我们可以使用Stream.of方法将数组转变为流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; a1 = Stream.of(a);</span><br></pre></td></tr></table></figure>

<p>of方法用的是可变参数，所以我们可以传入任意长度的数组</p>
<p>但是更加推荐Array.stream(array, from, to)方法，可以从数组的from到to创建一个流对象</p>
<p>如果想产生一个空的流，可以使用<code>Stream.empty()</code>方法</p>
<h2 id="为什么推荐Array-stream"><a href="#为什么推荐Array-stream" class="headerlink" title="为什么推荐Array.stream"></a>为什么推荐Array.stream</h2><p>对于对象类型的数组，Array.stream和Stream.of虽然有同样的返回，但是对于基本类型的数组，Stream.of.count返回的数组永远是1</p>
<p>对于这点可以自行验证。</p>
<h2 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h2><p>在Java8的流库中，有两个创建无限流的方法，generate和iterator</p>
<p>详细可以从另一篇博客《Java流中的generate与iterator》了解</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>iterator需要我们传入两个参数，<code>seed</code>和<code>initial element seed</code>，一个是初始值，一个是产生无限流的依据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; stream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(<span class="number">100</span>);</span><br><span class="line">System.out.println(Arrays.toString(stream.filter(n -&gt; n.compareTo(<span class="keyword">new</span> BigInteger(String.valueOf(<span class="number">170L</span>))) &lt; <span class="number">0</span>).toArray()));</span><br></pre></td></tr></table></figure>

<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>generate则需要我们传入一个Supplier对象，里面可以定义规则，比iterator更加灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Stream.generate(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).limit(<span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stream1.toArray()));</span><br></pre></td></tr></table></figure>

<p>或者说，generate可以根据多个元素制定规则，而iterator只能根据一个元素</p>
<p>在Java中，产生流的方式还有很多，比如Pattern.splitStream()、Files.lines()</p>
<p>Pattern.splitStream可以根据正则表达式来分割字符串形成一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.complie(<span class="string">&quot;\\PL+&quot;</span>).splitAsStream(content)</span><br></pre></td></tr></table></figure>

<p>而Files.lines(path)方法则可以返回一个包含文件中所有行的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path))&#123;</span><br><span class="line">    <span class="comment">// Process line</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="章节总结-1"><a href="#章节总结-1" class="headerlink" title="章节总结"></a>章节总结</h2><p>操作流API：</p>
<ul>
<li>of(T… values)：根据给定数组产生一个流</li>
<li>empty()：产生一个空的流</li>
<li>generate()：产生一个无限流</li>
<li>iterator()：产生一个无限流</li>
</ul>
<p>java.util.Arrays：</p>
<ul>
<li>stream(T[] Arrays, int start, int end)：根据数组创建一个流</li>
</ul>
<p>java.util.regex.Pattern：</p>
<ul>
<li>splitAsStream(CharSequence input)：根据input产生一个流</li>
</ul>
<p>java.nio.file.Files：</p>
<ul>
<li>stream(Path path, [Charset c])：将指定文件中的行转化为流，并且可以设置指定字符集</li>
</ul>
<p>java.util.function.Supplier：</p>
<ul>
<li>get()：提供一个值，用于产生无限流</li>
</ul>
<h1 id="filter、map和flatMap"><a href="#filter、map和flatMap" class="headerlink" title="filter、map和flatMap"></a>filter、map和flatMap</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter可以从一个流中转换出一个流，其中的元素遵循某种规则，可以在<code>filter()</code>括号中定义这个规则，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = wordList.stream().filter(w -&gt; w.length &gt; <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>这样这个流中就会只包含长度大于12的单词</p>
<p>filter更像是从一个流中筛选元素，组成另一个流</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>相比于filter，map虽然也是产生一个新的流，但是map是将原来的流中的元素进行转换，比如将words中的单词全部小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = wordList.stream().map(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<p>或者你可以自定义一个函数，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 核心技术卷II.JavaSe8的流库.流方法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/10 21:24:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect = words.stream().map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; collect1 = words.stream().map(w -&gt; myMap(w).collect(Collectors.toList())).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">myMap</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            list.add(s.substring(i, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[abc, bcd, java, golang, rust]</span><br><span class="line">[[A, b, c], [B, c, d], [J, a, v, a], [G, o, L, a, n, g], [R, u, s, t]]</span><br></pre></td></tr></table></figure>

<p>但是这样每个单词都是一个List，我们可能并不想出现这种情况，这时候flatMap方法就派上用场了</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>flatMap可以将当前流中的所有元素拼接到一起返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect2 = words.stream().flatMap(w -&gt; myMap(w)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line">[A, b, c, B, c, d, J, a, v, a, G, o, L, a, n, g, R, u, s, t]</span><br></pre></td></tr></table></figure>

<p>返回一个流，其中包含将<strong>该流的每个元素</strong>替换为将提供的映射函数应用到每个元素所产生的映射流的内容的结果。每个被映射的流在其内容被放置到这个流之后被关闭。</p>
<p>而map是单个元素</p>
<h2 id="章节总结-2"><a href="#章节总结-2" class="headerlink" title="章节总结"></a>章节总结</h2><p>java.util.Stream：</p>
<ul>
<li>filter：产生一个流，其中包含当前流中所有满足条件的元素</li>
<li>map(Function&lt;? super T&gt; mapper)：产生一个流，其中包含将mapper应用于流中的每一个元素所产生的结果</li>
<li>flatMap(Function mapper)：产生一个流，其中包含将mapper应用于流中每一个元素所产生的结果的组合</li>
</ul>
<h1 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h1><h2 id="抽取流"><a href="#抽取流" class="headerlink" title="抽取流"></a>抽取流</h2><p>在介绍无限流的时候，有一个API叫<code>limit()</code>，这个API会产生一个新的流，并且在流运行到第n个元素时结束，对裁剪无限流非常好用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; collect = Stream.generate(Math::random).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure>

<p>这个流就只包含五个随机数</p>
<p>而<code>stream.skip(long n)</code>API正好相反，这个API会在跳过前n个元素，对后面的元素进行截取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect1 = words.stream().skip(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">[Java, GoLang, Rust]</span><br></pre></td></tr></table></figure>

<p>返回的流跳过了前两个元素</p>
<h2 id="连接流"><a href="#连接流" class="headerlink" title="连接流"></a>连接流</h2><p>如果想要将两个Luis连接起来，可以使用<code>stream.contact(Stream a, Stream b)</code>将两个流进行连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; collect2 = Stream.concat(collect.stream(), collect1.stream()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">[<span class="number">0.19283510014488758</span>, <span class="number">0.986608060762175</span>, <span class="number">0.07406377892420113</span>, <span class="number">0.6737128935974602</span>, <span class="number">0.5210312651857187</span>, Java, GoLang, Rust]</span><br></pre></td></tr></table></figure>

<h2 id="章节总结-3"><a href="#章节总结-3" class="headerlink" title="章节总结"></a>章节总结</h2><p>本章一共介绍了三个API，两个抽取子流，一个拼接流</p>
<p>java.util.Stream：</p>
<ul>
<li>limit(long maxSize)：抽取流中最初的maxSize个元素，并返回一个新的流</li>
<li>skip(long n)：抽取流中除了前n个元素之前的元素，并返回一个新的流</li>
<li>contact(Stream a, Stream b)：拼接两个流，并返回一个新的流</li>
</ul>
<h1 id="其他流的转换"><a href="#其他流的转换" class="headerlink" title="其他流的转换"></a>其他流的转换</h1><p><code>distinct()</code>函数能够帮助我们从一个流中返回一个新的流，并且没有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/29 21:05:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTrans</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;gently&quot;</span>);</span><br><span class="line">        <span class="comment">// 流只能使用一次！！！！</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(a.toArray()));</span></span><br><span class="line">        System.out.println(Arrays.toString(a.distinct().toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与数组一样，我们可以使用<code>sorted()</code>对流进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=========流排序========&quot;</span>);</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; str1 = Stream.of(str);</span><br><span class="line">        Object[] objects = str1.sorted(Comparator.comparing(String::length)).toArray();</span><br><span class="line">        System.out.println(Arrays.toString(objects));</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用数组进行排序，但是当排序方法是流管道的一部分时，sorted函数就显得非常有用</p>
<p>最后还有一个<code>peek</code>函数，这个函数和<code>map</code>有一些类似，都是产生一个新的流，并且对元素进行一些处理，但是<code>map</code>是处理元素值，<code>peek</code>是执行函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;=========peek========&quot;</span>);</span><br><span class="line">      Stream&lt;String&gt; str2 = Stream.of(str);</span><br><span class="line">      Stream&lt;String&gt; peek = str2.peek(System.out::println);</span><br><span class="line">      System.out.println(Arrays.toString(peek.toArray()));</span><br></pre></td></tr></table></figure>

<p>这样就会将数组逐个输出。</p>
<h2 id="章节总结-4"><a href="#章节总结-4" class="headerlink" title="章节总结"></a>章节总结</h2><h3 id="java-util-stream-Stream"><a href="#java-util-stream-Stream" class="headerlink" title="java.util.stream.Stream"></a>java.util.stream.Stream</h3><ul>
<li>Stream<T> distinct()：产生一个新的流，剔除当前流中的重复元素</li>
<li>Stream<T> sorted()</li>
<li>Stream<T> sorted(Comparator&lt;? super T&gt; comparator)：产生一个新的流并且进行排序</li>
<li>Stream<T> peek(Consumer&lt;? super T&gt; action)：产生一个新的流，与当前元素相同，并且在获取其中每个元素时都会传递给action</li>
</ul>
<h1 id="简单约简"><a href="#简单约简" class="headerlink" title="简单约简"></a>简单约简</h1><p>我们已经看到了如何创建和转换流，终于可以来一点有意思的东西了：从数据流中获取答案，这种方法被称为约简。这是一种<code>终结操作</code>，他们<strong>会将流约简成可以在程序中使用的非流值</strong>。</p>
<p>之前我们已经使用过<code>count</code>，这就是一种简单约简，同样的还有<code>max</code>和<code>min</code>，这些方法的返回值是一个<code>Optional&lt;T&gt;</code>，它会在其中包装答案，或者什么都不做（流值为空），在以前这种操作容易造成空指针异常，在下一节中我们会详细讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; words1 = Stream.of(words);</span><br><span class="line">        Optional&lt;String&gt; max = words1.max(String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法展示了如何获取流的最大值，但是结果和我们想象的不太一样</p>
<p><code>Optional[Rust]</code></p>
<p>还有找到第一个以G开头的单词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====findFirst====&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; g = Stream.of(words).filter(e -&gt; e.startsWith(<span class="string">&quot;G&quot;</span>)).findFirst();</span><br><span class="line">System.out.println(g);</span><br></pre></td></tr></table></figure>

<p>如果不强制匹配第一个，那么可以使用<code>findAny</code>，这个方法在处理并行流时很有效</p>
<p>或者只是想知道有没有存在某个值符合，可以使用<code>anyMatch</code>来进行匹配，这个函数会返回一个boolean，而不是具体的值，同时，这个方法需要接受一个断言引元，而不是filter，就像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> g2 = Stream.of(words).anyMatch(e -&gt; e.startsWith(<span class="string">&quot;G&quot;</span>));</span><br><span class="line">System.out.println(g2);</span><br></pre></td></tr></table></figure>



<p>还有<code>allMatch</code>和<code>noneMatch</code>，分别会在全部符合或者没有符合时返回<code>true</code></p>
<h2 id="章节总结-5"><a href="#章节总结-5" class="headerlink" title="章节总结"></a>章节总结</h2><h3 id="java-util-stream-Stream-1"><a href="#java-util-stream-Stream-1" class="headerlink" title="java.util.stream.Stream"></a>java.util.stream.Stream</h3><ul>
<li>Optional<T> max(Comparator&lt;? super T&gt; comparator)</li>
<li>Optional<T> min(Comparator&lt;? super T&gt; comparator)：这两个方法分别会返回最大元素和最小远古三</li>
<li>Optional<T> findFirst()</li>
<li>Optional<T> findAny()：分别产生这个流的第一个元素和任意一个元素</li>
<li>Optional<T> anyMatch(Predicate&lt;? super T&gt; predicate)</li>
<li>Optional<T> allMatch(Predicate&lt;? super T&gt; predicate)</li>
<li>Optional<T> noneMatch(Predicate&lt;? super T&gt; predicate)：分别在这个流中任意元素、所有元素和没有任何元素匹配时返回<code>true</code></li>
</ul>
<h1 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a>Optional类型</h1><p>上一节中我们使用到了这个对象，这节来自习介绍一下</p>
<p>Optional类型是一种包装器对象，要么包装了类型T的对象，要么没有包装任何对象，用于解决空指针异常问题。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Optional是一个很好用的东西，如果值不存在的状态下，它会自动产生一个替代的值</p>
<p>第一种情况：</p>
<p>如果某个值不存在，我们想要用一个空字符串去代替他</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = a.orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>或者调用一个方法去计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = a.orElseGet(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(System.currentTimeMillis());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>又或者是抛出一个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = a.orElseThrow(IllegalAccessError::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>这些方法在不存在任何值时会产生一个相应的替代物；还有一个函数可以选择只有在值存在的情况下才进行消费。</p>
<p><code>ifPresent</code>只会在值存在的情况下才会接受一个函数，否则不会发生任何事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; b = Optional.of(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">b.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>isPresent</code>时，这个函数不会返回任何值，如果想要获取处理的结果，可以使用<code>map</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Optional&lt;Boolean&gt; aBoolean = b.map(result::add);</span><br><span class="line">System.out.println(aBoolean);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里的aBoolean有三种值，<code>true</code>和<code>false</code>所对应的Option，和空值所对应的Option</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional"><a href="#java-util-Optional" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>T orElsr(T other)：产生这个Optional的值，在值为空时，返回other</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other)：产生这个Optional的值，在值为空时，返回other这个<strong>方法</strong>所返回的结果</li>
<li><X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; action)：返回Optional的值，值为空时，抛出action返回的结果</li>
<li>void isPresent(Consumer&lt;? super T&gt; consumer)：如果值不为空，就将值传递给consumer这个<strong>方法</strong> </li>
<li><U> Optional<U> map(Function&lt;? super T, ?extends U&gt; mapper)：将值传递给mapper并产生返回结果，如果值为空，返回也是一个空Optional</li>
</ul>
<h2 id="不适合使用Optional值的方式"><a href="#不适合使用Optional值的方式" class="headerlink" title="不适合使用Optional值的方式"></a>不适合使用Optional值的方式</h2><p>如果没有正确使用Optional的值，那么相比较其他获得<code>null</code>的方式，并没有任何区别。</p>
<p><code>get</code>方法会在Optional值存在IDE情况下获得其中包装的元素，或者在不存在的情况下抛出一个<code>NoSuchElementException</code>对象，所以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional = ...;</span><br><span class="line">optional.get().method();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T a = <span class="keyword">new</span> T();</span><br><span class="line">a.method();</span><br></pre></td></tr></table></figure>

<p>以上两种用法并没有太大区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional = ...;</span><br><span class="line"><span class="keyword">if</span> (optional.isPresent())&#123;</span><br><span class="line">    optional.get().method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T value = ...;</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) value.method();</span><br></pre></td></tr></table></figure>

<p>这两种方法也没有什么区别</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-1"><a href="#java-util-Optional-1" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>T get()：产生这个Optional的值，或者在值为空时，抛出一个<code>NoSuchElementException</code>异常</li>
<li>boolean isPresent()：如果值不为空，返回true</li>
</ul>
<h2 id="创建Optional值"><a href="#创建Optional值" class="headerlink" title="创建Optional值"></a>创建Optional值</h2><p>现在我们已经知道了如何使用Optional值，但是对于如何创建我们一无所知</p>
<p>有多个方法可以用于创建Optional，例如：</p>
<ul>
<li>Optional.of(T value)</li>
<li>Optional.empty()</li>
</ul>
<p>或者如果不确定有没有这个value，也可以使用<code>Optional.ofNullable(T value)</code>，这个函数会根据value是否存在去调用<code>Optional.empty</code>或是<code>Optional.of()</code></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-2"><a href="#java-util-Optional-2" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>static <T> Optional<T> of(T value)</li>
<li>static <T> Optional<T> empty()：产生一格具有给定值的Optional，如果值为空，of会抛出一个NullPointerException异常，empty会返回一个空Optional</li>
<li>static <T> Optional<T> ofNullable(T value)：如果value存在调用of，不存在调用empty</li>
</ul>
<h2 id="用flatMap构建Optional值的函数"><a href="#用flatMap构建Optional值的函数" class="headerlink" title="用flatMap构建Optional值的函数"></a>用flatMap构建Optional值的函数</h2><p>考虑这样一种场景，你有一个能够生成<code>Optional&lt;T&gt;</code>对象的方法<code>f</code>，<code>T</code>又有一个能够返回<code>Optional&lt;U&gt;</code>的方法<code>g</code>，如果想要通过f方法创建<code>Optional&lt;U&gt;</code>对象，可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;U&gt; result = s.f().flatMap(T::g);</span><br></pre></td></tr></table></figure>

<p>如果<code>s.f()</code>的值存在，那么<code>g</code>就可以应用到它上面，否则会产生一个空Optional</p>
<p>通过这种方式我们可以疯狂使用<code>flatMap</code>构建Optional，从而构建由这些步骤组成的管道，当所有步骤成功时，该管道才会成功</p>
<p>在之前我们见过<code>Stream.flatMap()</code>，但是这里的flatMap和stream的不太一样。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-3"><a href="#java-util-Optional-3" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li><U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)：产生将mapper应用于当前的Optional值所产生的结果，或者在当前Optional为空时，返回一个空Optional</li>
</ul>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><p>当处理完流之后，如果想要查看其中的元素，我们可以使用<code>iterator</code>迭代器，或者<code>foreach</code>将某个函数应用到流中的每一个元素上去。</p>
<p>当然，在并行流上<code>foreach</code>方法会导致访问顺序不一致，如果想要按照流原来的顺序进行访问，需要使用<code>forEachOrderd</code>方法，同时这个方法也会丧失并行流的部分甚至全部优势。</p>
<p>或者我们可以将流转化为Array类型。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/JiangLiuJL">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=ZJIyoBCxTJBHdyrsTC-0bZ6_wV7v8ztt&amp;noverify=0">联系我</a></span>
        <span>/</span>
        
        <span><a href="https://jiangliujl.github.io/about/">JiangLiu&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
    data-repo="aircloud/hexo-aircloud-blog"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjkwNDgyNjg="
    data-category="Announcements"
    data-category-id="DIC_kwDOB7EezM4COhKJ"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async>
</script>




</html>
