<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="江流的博客">
    <meta property="og:type" content="website">
    <meta name="description" content="江流的博客">
    <meta name="keyword"  content="江流的博客，Java开发">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        《Java流操作》——读书笔记 - JiangLiu 日常
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="江流的个人博客" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 一名落魄的Java程序员 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>JiangLiu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E8%BF%AD%E4%BB%A3%E5%88%B0%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">从迭代到流的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream%E5%92%8CparallelStream"><span class="toc-text">stream和parallelStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">流的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90Array-stream"><span class="toc-text">为什么推荐Array.stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E6%B5%81"><span class="toc-text">无限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator"><span class="toc-text">iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generate"><span class="toc-text">generate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-1"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#filter%E3%80%81map%E5%92%8CflatMap"><span class="toc-text">filter、map和flatMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flatMap"><span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-2"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%AD%90%E6%B5%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B5%81"><span class="toc-text">抽取子流和连接流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E6%B5%81"><span class="toc-text">抽取流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B5%81"><span class="toc-text">连接流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-3"><span class="toc-text">章节总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">其他流的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-4"><span class="toc-text">章节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-Stream"><span class="toc-text">java.util.stream.Stream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BA%A6%E7%AE%80"><span class="toc-text">简单约简</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93-5"><span class="toc-text">章节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-Stream-1"><span class="toc-text">java.util.stream.Stream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional%E7%B1%BB%E5%9E%8B"><span class="toc-text">Optional类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8Optional%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">不适合使用Optional值的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-1"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAOptional%E5%80%BC"><span class="toc-text">创建Optional值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-2"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8flatMap%E6%9E%84%E5%BB%BAOptional%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">用flatMap构建Optional值的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-Optional-3"><span class="toc-text">java.util.Optional</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%9C"><span class="toc-text">收集结果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-BaseStream"><span class="toc-text">java.util.stream.BaseStream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%88%B0%E6%98%A0%E5%B0%84%E8%A1%A8%E4%B8%AD"><span class="toc-text">收集到映射表中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BE%A4%E7%BB%84%E5%92%8C%E5%88%86%E5%8C%BA"><span class="toc-text">群组和分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-Collector"><span class="toc-text">java.util.stream.Collector</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E6%B8%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">下游收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本流类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-IntStream"><span class="toc-text">java.util.stream.IntStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-LongStream"><span class="toc-text">java.util.stream.LongStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-DoubleStream"><span class="toc-text">java.util.stream.DoubleStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-CharSequence"><span class="toc-text">java.lang.CharSequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Random"><span class="toc-text">java.util.Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Optional-Int-Long-Double"><span class="toc-text">java.util.Optional(Int&#x2F;Long&#x2F;Double)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Int-Long-Double-SummaryStatistics"><span class="toc-text">java.util.(Int&#x2F;Long&#x2F;Double) SummaryStatistics</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-text">并行流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A"><span class="toc-text">警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-stream-BaseStream-1"><span class="toc-text">java.util.stream.BaseStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Collection"><span class="toc-text">java.util.Collection</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 一名落魄的Java程序员 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        《Java流操作》——读书笔记
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2022-08-10 00:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Java" title="Java">Java</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#Java流" title="Java流">Java流</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h1><p>处理集合时，我们常常会遍历他们的元素，然后对其中的元素做一些操作，例如我们如果想从一个文件中读取一个字符串，然后用非字母对他们进行分割，我们一般会这么干</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 非字母分隔符</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">System.out.println(words);</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以尝试用流的操作替代循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        String contents = Files.readString(Paths.get(<span class="string">&quot;D:/001_program/JavaProgram/JavaBase/src/main/java/核心技术卷II/JavaSe8的流库/从迭代到流的操作/alice.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 非字母分隔符</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));</span><br><span class="line">        System.out.println(words);</span><br><span class="line"><span class="comment">//        for (String word : words) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(word);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">long</span> count1 = words.stream().filter(Objects::nonNull).count();</span><br><span class="line">        System.out.println(count1);</span><br></pre></td></tr></table></figure>

<p>就像这样，这比循环更加简洁</p>
<h2 id="stream和parallelStream"><a href="#stream和parallelStream" class="headerlink" title="stream和parallelStream"></a>stream和parallelStream</h2><p>在Java中，这两种都是流操作，但是它们两个有一些区别</p>
<ul>
<li>stream是串行流，也就是说stream流中的元素是一个一个顺序执行的</li>
<li>而parallelStream是并行流，可以以并行方式来进行过滤和计数</li>
</ul>
<p>至于并行流，在后面会详细介绍</p>
<p>流操作表面上和集合是非常相似的，但是它们有着非常显著的差异：</p>
<ul>
<li>流操作并不存储元素。这些元素储存在底层的集合中按需生成。</li>
<li>流操作并不会修改数据源，而是产生一个新的流</li>
<li>流的操作是尽可能惰性执行的。比如我们想要查找前五个长单词而不是所有长单词，那么流就会在匹配到第五个长单词时停止过滤，因此按理说我们可以操作无限流。</li>
</ul>
<h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><p>流操作API：</p>
<ul>
<li>filter(Predicate&lt;? super T&gt; P)：产生一个流，其中包含所有满足P的元素</li>
<li>count()：计算当前流中元素的数量</li>
</ul>
<p>流的种类：</p>
<ul>
<li>stream：串行流</li>
<li>parallelStream：并行流</li>
</ul>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><p>我们已经知道用Collection类的stream方法可以将一个集合转化为流，当然，不止集合，数组也可以</p>
<p>对于一个数组，我们可以使用Stream.of方法将数组转变为流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; a1 = Stream.of(a);</span><br></pre></td></tr></table></figure>

<p>of方法用的是可变参数，所以我们可以传入任意长度的数组</p>
<p>但是更加推荐Array.stream(array, from, to)方法，可以从数组的from到to创建一个流对象</p>
<p>如果想产生一个空的流，可以使用<code>Stream.empty()</code>方法</p>
<h2 id="为什么推荐Array-stream"><a href="#为什么推荐Array-stream" class="headerlink" title="为什么推荐Array.stream"></a>为什么推荐Array.stream</h2><p>对于对象类型的数组，Array.stream和Stream.of虽然有同样的返回，但是对于基本类型的数组，Stream.of.count返回的数组永远是1</p>
<p>对于这点可以自行验证。</p>
<h2 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h2><p>在Java8的流库中，有两个创建无限流的方法，generate和iterator</p>
<p>详细可以从另一篇博客《Java流中的generate与iterator》了解</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>iterator需要我们传入两个参数，<code>seed</code>和<code>initial element seed</code>，一个是初始值，一个是产生无限流的依据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; stream = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(<span class="number">100</span>);</span><br><span class="line">System.out.println(Arrays.toString(stream.filter(n -&gt; n.compareTo(<span class="keyword">new</span> BigInteger(String.valueOf(<span class="number">170L</span>))) &lt; <span class="number">0</span>).toArray()));</span><br></pre></td></tr></table></figure>

<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>generate则需要我们传入一个Supplier对象，里面可以定义规则，比iterator更加灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Stream.generate(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).limit(<span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stream1.toArray()));</span><br></pre></td></tr></table></figure>

<p>或者说，generate可以根据多个元素制定规则，而iterator只能根据一个元素</p>
<p>在Java中，产生流的方式还有很多，比如Pattern.splitStream()、Files.lines()</p>
<p>Pattern.splitStream可以根据正则表达式来分割字符串形成一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.complie(<span class="string">&quot;\\PL+&quot;</span>).splitAsStream(content)</span><br></pre></td></tr></table></figure>

<p>而Files.lines(path)方法则可以返回一个包含文件中所有行的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path))&#123;</span><br><span class="line">    <span class="comment">// Process line</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="章节总结-1"><a href="#章节总结-1" class="headerlink" title="章节总结"></a>章节总结</h2><p>操作流API：</p>
<ul>
<li>of(T… values)：根据给定数组产生一个流</li>
<li>empty()：产生一个空的流</li>
<li>generate()：产生一个无限流</li>
<li>iterator()：产生一个无限流</li>
</ul>
<p>java.util.Arrays：</p>
<ul>
<li>stream(T[] Arrays, int start, int end)：根据数组创建一个流</li>
</ul>
<p>java.util.regex.Pattern：</p>
<ul>
<li>splitAsStream(CharSequence input)：根据input产生一个流</li>
</ul>
<p>java.nio.file.Files：</p>
<ul>
<li>stream(Path path, [Charset c])：将指定文件中的行转化为流，并且可以设置指定字符集</li>
</ul>
<p>java.util.function.Supplier：</p>
<ul>
<li>get()：提供一个值，用于产生无限流</li>
</ul>
<h1 id="filter、map和flatMap"><a href="#filter、map和flatMap" class="headerlink" title="filter、map和flatMap"></a>filter、map和flatMap</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter可以从一个流中转换出一个流，其中的元素遵循某种规则，可以在<code>filter()</code>括号中定义这个规则，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = wordList.stream().filter(w -&gt; w.length &gt; <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>这样这个流中就会只包含长度大于12的单词</p>
<p>filter更像是从一个流中筛选元素，组成另一个流</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>相比于filter，map虽然也是产生一个新的流，但是map是将原来的流中的元素进行转换，比如将words中的单词全部小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = wordList.stream().map(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<p>或者你可以自定义一个函数，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 核心技术卷II.JavaSe8的流库.流方法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/10 21:24:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect = words.stream().map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; collect1 = words.stream().map(w -&gt; myMap(w).collect(Collectors.toList())).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">myMap</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            list.add(s.substring(i, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[abc, bcd, java, golang, rust]</span><br><span class="line">[[A, b, c], [B, c, d], [J, a, v, a], [G, o, L, a, n, g], [R, u, s, t]]</span><br></pre></td></tr></table></figure>

<p>但是这样每个单词都是一个List，我们可能并不想出现这种情况，这时候flatMap方法就派上用场了</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>flatMap可以将当前流中的所有元素拼接到一起返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect2 = words.stream().flatMap(w -&gt; myMap(w)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line">[A, b, c, B, c, d, J, a, v, a, G, o, L, a, n, g, R, u, s, t]</span><br></pre></td></tr></table></figure>

<p>返回一个流，其中包含将<strong>该流的每个元素</strong>替换为将提供的映射函数应用到每个元素所产生的映射流的内容的结果。每个被映射的流在其内容被放置到这个流之后被关闭。</p>
<p>而map是单个元素</p>
<h2 id="章节总结-2"><a href="#章节总结-2" class="headerlink" title="章节总结"></a>章节总结</h2><p>java.util.Stream：</p>
<ul>
<li>filter：产生一个流，其中包含当前流中所有满足条件的元素</li>
<li>map(Function&lt;? super T&gt; mapper)：产生一个流，其中包含将mapper应用于流中的每一个元素所产生的结果</li>
<li>flatMap(Function mapper)：产生一个流，其中包含将mapper应用于流中每一个元素所产生的结果的组合</li>
</ul>
<h1 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h1><h2 id="抽取流"><a href="#抽取流" class="headerlink" title="抽取流"></a>抽取流</h2><p>在介绍无限流的时候，有一个API叫<code>limit()</code>，这个API会产生一个新的流，并且在流运行到第n个元素时结束，对裁剪无限流非常好用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; collect = Stream.generate(Math::random).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure>

<p>这个流就只包含五个随机数</p>
<p>而<code>stream.skip(long n)</code>API正好相反，这个API会在跳过前n个元素，对后面的元素进行截取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;Abc&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Bcd&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">        List&lt;String&gt; collect1 = words.stream().skip(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">[Java, GoLang, Rust]</span><br></pre></td></tr></table></figure>

<p>返回的流跳过了前两个元素</p>
<h2 id="连接流"><a href="#连接流" class="headerlink" title="连接流"></a>连接流</h2><p>如果想要将两个Luis连接起来，可以使用<code>stream.contact(Stream a, Stream b)</code>将两个流进行连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; collect2 = Stream.concat(collect.stream(), collect1.stream()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">[<span class="number">0.19283510014488758</span>, <span class="number">0.986608060762175</span>, <span class="number">0.07406377892420113</span>, <span class="number">0.6737128935974602</span>, <span class="number">0.5210312651857187</span>, Java, GoLang, Rust]</span><br></pre></td></tr></table></figure>

<h2 id="章节总结-3"><a href="#章节总结-3" class="headerlink" title="章节总结"></a>章节总结</h2><p>本章一共介绍了三个API，两个抽取子流，一个拼接流</p>
<p>java.util.Stream：</p>
<ul>
<li>limit(long maxSize)：抽取流中最初的maxSize个元素，并返回一个新的流</li>
<li>skip(long n)：抽取流中除了前n个元素之前的元素，并返回一个新的流</li>
<li>contact(Stream a, Stream b)：拼接两个流，并返回一个新的流</li>
</ul>
<h1 id="其他流的转换"><a href="#其他流的转换" class="headerlink" title="其他流的转换"></a>其他流的转换</h1><p><code>distinct()</code>函数能够帮助我们从一个流中返回一个新的流，并且没有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JiangLiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/8/29 21:05:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTrans</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;gently&quot;</span>);</span><br><span class="line">        <span class="comment">// 流只能使用一次！！！！</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(a.toArray()));</span></span><br><span class="line">        System.out.println(Arrays.toString(a.distinct().toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与数组一样，我们可以使用<code>sorted()</code>对流进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=========流排序========&quot;</span>);</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; str1 = Stream.of(str);</span><br><span class="line">        Object[] objects = str1.sorted(Comparator.comparing(String::length)).toArray();</span><br><span class="line">        System.out.println(Arrays.toString(objects));</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用数组进行排序，但是当排序方法是流管道的一部分时，sorted函数就显得非常有用</p>
<p>最后还有一个<code>peek</code>函数，这个函数和<code>map</code>有一些类似，都是产生一个新的流，并且对元素进行一些处理，但是<code>map</code>是处理元素值，<code>peek</code>是执行函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;=========peek========&quot;</span>);</span><br><span class="line">      Stream&lt;String&gt; str2 = Stream.of(str);</span><br><span class="line">      Stream&lt;String&gt; peek = str2.peek(System.out::println);</span><br><span class="line">      System.out.println(Arrays.toString(peek.toArray()));</span><br></pre></td></tr></table></figure>

<p>这样就会将数组逐个输出。</p>
<h2 id="章节总结-4"><a href="#章节总结-4" class="headerlink" title="章节总结"></a>章节总结</h2><h3 id="java-util-stream-Stream"><a href="#java-util-stream-Stream" class="headerlink" title="java.util.stream.Stream"></a>java.util.stream.Stream</h3><ul>
<li>Stream<T> distinct()：产生一个新的流，剔除当前流中的重复元素</li>
<li>Stream<T> sorted()</li>
<li>Stream<T> sorted(Comparator&lt;? super T&gt; comparator)：产生一个新的流并且进行排序</li>
<li>Stream<T> peek(Consumer&lt;? super T&gt; action)：产生一个新的流，与当前元素相同，并且在获取其中每个元素时都会传递给action</li>
</ul>
<h1 id="简单约简"><a href="#简单约简" class="headerlink" title="简单约简"></a>简单约简</h1><p>我们已经看到了如何创建和转换流，终于可以来一点有意思的东西了：从数据流中获取答案，这种方法被称为约简。这是一种<code>终结操作</code>，他们<strong>会将流约简成可以在程序中使用的非流值</strong>。</p>
<p>之前我们已经使用过<code>count</code>，这就是一种简单约简，同样的还有<code>max</code>和<code>min</code>，这些方法的返回值是一个<code>Optional&lt;T&gt;</code>，它会在其中包装答案，或者什么都不做（流值为空），在以前这种操作容易造成空指针异常，在下一节中我们会详细讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; words1 = Stream.of(words);</span><br><span class="line">        Optional&lt;String&gt; max = words1.max(String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法展示了如何获取流的最大值，但是结果和我们想象的不太一样</p>
<p><code>Optional[Rust]</code></p>
<p>还有找到第一个以G开头的单词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====findFirst====&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; g = Stream.of(words).filter(e -&gt; e.startsWith(<span class="string">&quot;G&quot;</span>)).findFirst();</span><br><span class="line">System.out.println(g);</span><br></pre></td></tr></table></figure>

<p>如果不强制匹配第一个，那么可以使用<code>findAny</code>，这个方法在处理并行流时很有效</p>
<p>或者只是想知道有没有存在某个值符合，可以使用<code>anyMatch</code>来进行匹配，这个函数会返回一个boolean，而不是具体的值，同时，这个方法需要接受一个断言引元，而不是filter，就像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> g2 = Stream.of(words).anyMatch(e -&gt; e.startsWith(<span class="string">&quot;G&quot;</span>));</span><br><span class="line">System.out.println(g2);</span><br></pre></td></tr></table></figure>



<p>还有<code>allMatch</code>和<code>noneMatch</code>，分别会在全部符合或者没有符合时返回<code>true</code></p>
<h2 id="章节总结-5"><a href="#章节总结-5" class="headerlink" title="章节总结"></a>章节总结</h2><h3 id="java-util-stream-Stream-1"><a href="#java-util-stream-Stream-1" class="headerlink" title="java.util.stream.Stream"></a>java.util.stream.Stream</h3><ul>
<li>Optional<T> max(Comparator&lt;? super T&gt; comparator)</li>
<li>Optional<T> min(Comparator&lt;? super T&gt; comparator)：这两个方法分别会返回最大元素和最小远古三</li>
<li>Optional<T> findFirst()</li>
<li>Optional<T> findAny()：分别产生这个流的第一个元素和任意一个元素</li>
<li>Optional<T> anyMatch(Predicate&lt;? super T&gt; predicate)</li>
<li>Optional<T> allMatch(Predicate&lt;? super T&gt; predicate)</li>
<li>Optional<T> noneMatch(Predicate&lt;? super T&gt; predicate)：分别在这个流中任意元素、所有元素和没有任何元素匹配时返回<code>true</code></li>
</ul>
<h1 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a>Optional类型</h1><p>上一节中我们使用到了这个对象，这节来自习介绍一下</p>
<p>Optional类型是一种包装器对象，要么包装了类型T的对象，要么没有包装任何对象，用于解决空指针异常问题。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Optional是一个很好用的东西，如果值不存在的状态下，它会自动产生一个替代的值</p>
<p>第一种情况：</p>
<p>如果某个值不存在，我们想要用一个空字符串去代替他</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = a.orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>或者调用一个方法去计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = a.orElseGet(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(System.currentTimeMillis());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>又或者是抛出一个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = a.orElseThrow(IllegalAccessError::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>这些方法在不存在任何值时会产生一个相应的替代物；还有一个函数可以选择只有在值存在的情况下才进行消费。</p>
<p><code>ifPresent</code>只会在值存在的情况下才会接受一个函数，否则不会发生任何事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; b = Optional.of(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">b.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>isPresent</code>时，这个函数不会返回任何值，如果想要获取处理的结果，可以使用<code>map</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Optional&lt;Boolean&gt; aBoolean = b.map(result::add);</span><br><span class="line">System.out.println(aBoolean);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里的aBoolean有三种值，<code>true</code>和<code>false</code>所对应的Option，和空值所对应的Option</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional"><a href="#java-util-Optional" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>T orElsr(T other)：产生这个Optional的值，在值为空时，返回other</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other)：产生这个Optional的值，在值为空时，返回other这个<strong>方法</strong>所返回的结果</li>
<li><X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; action)：返回Optional的值，值为空时，抛出action返回的结果</li>
<li>void isPresent(Consumer&lt;? super T&gt; consumer)：如果值不为空，就将值传递给consumer这个<strong>方法</strong> </li>
<li><U> Optional<U> map(Function&lt;? super T, ?extends U&gt; mapper)：将值传递给mapper并产生返回结果，如果值为空，返回也是一个空Optional</li>
</ul>
<h2 id="不适合使用Optional值的方式"><a href="#不适合使用Optional值的方式" class="headerlink" title="不适合使用Optional值的方式"></a>不适合使用Optional值的方式</h2><p>如果没有正确使用Optional的值，那么相比较其他获得<code>null</code>的方式，并没有任何区别。</p>
<p><code>get</code>方法会在Optional值存在IDE情况下获得其中包装的元素，或者在不存在的情况下抛出一个<code>NoSuchElementException</code>对象，所以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional = ...;</span><br><span class="line">optional.get().method();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T a = <span class="keyword">new</span> T();</span><br><span class="line">a.method();</span><br></pre></td></tr></table></figure>

<p>以上两种用法并没有太大区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional = ...;</span><br><span class="line"><span class="keyword">if</span> (optional.isPresent())&#123;</span><br><span class="line">    optional.get().method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T value = ...;</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) value.method();</span><br></pre></td></tr></table></figure>

<p>这两种方法也没有什么区别</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-1"><a href="#java-util-Optional-1" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>T get()：产生这个Optional的值，或者在值为空时，抛出一个<code>NoSuchElementException</code>异常</li>
<li>boolean isPresent()：如果值不为空，返回true</li>
</ul>
<h2 id="创建Optional值"><a href="#创建Optional值" class="headerlink" title="创建Optional值"></a>创建Optional值</h2><p>现在我们已经知道了如何使用Optional值，但是对于如何创建我们一无所知</p>
<p>有多个方法可以用于创建Optional，例如：</p>
<ul>
<li>Optional.of(T value)</li>
<li>Optional.empty()</li>
</ul>
<p>或者如果不确定有没有这个value，也可以使用<code>Optional.ofNullable(T value)</code>，这个函数会根据value是否存在去调用<code>Optional.empty</code>或是<code>Optional.of()</code></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-2"><a href="#java-util-Optional-2" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li>static <T> Optional<T> of(T value)</li>
<li>static <T> Optional<T> empty()：产生一格具有给定值的Optional，如果值为空，of会抛出一个NullPointerException异常，empty会返回一个空Optional</li>
<li>static <T> Optional<T> ofNullable(T value)：如果value存在调用of，不存在调用empty</li>
</ul>
<h2 id="用flatMap构建Optional值的函数"><a href="#用flatMap构建Optional值的函数" class="headerlink" title="用flatMap构建Optional值的函数"></a>用flatMap构建Optional值的函数</h2><p>考虑这样一种场景，你有一个能够生成<code>Optional&lt;T&gt;</code>对象的方法<code>f</code>，<code>T</code>又有一个能够返回<code>Optional&lt;U&gt;</code>的方法<code>g</code>，如果想要通过f方法创建<code>Optional&lt;U&gt;</code>对象，可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;U&gt; result = s.f().flatMap(T::g);</span><br></pre></td></tr></table></figure>

<p>如果<code>s.f()</code>的值存在，那么<code>g</code>就可以应用到它上面，否则会产生一个空Optional</p>
<p>通过这种方式我们可以疯狂使用<code>flatMap</code>构建Optional，从而构建由这些步骤组成的管道，当所有步骤成功时，该管道才会成功</p>
<p>在之前我们见过<code>Stream.flatMap()</code>，但是这里的flatMap和stream的不太一样。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><h4 id="java-util-Optional-3"><a href="#java-util-Optional-3" class="headerlink" title="java.util.Optional"></a>java.util.Optional</h4><ul>
<li><U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)：产生将mapper应用于当前的Optional值所产生的结果，或者在当前Optional为空时，返回一个空Optional</li>
</ul>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><p>当处理完流之后，如果想要查看其中的元素，我们可以使用<code>iterator</code>迭代器，或者<code>foreach</code>将某个函数应用到流中的每一个元素上去。</p>
<p>当然，在并行流上<code>foreach</code>方法会导致访问顺序不一致，如果想要按照流原来的顺序进行访问，需要使用<code>forEachOrderd</code>方法，同时这个方法也会丧失并行流的部分甚至全部优势。</p>
<p>或者我们可以使用<code>stream.toArray()</code>将流转化为Array类型。</p>
<p>或者<code>stream</code>提供了一个<code>collect</code>方法，它接受一个<code>Collector</code>实例，可以直接将流收集到列表或集合中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">List&lt;String&gt; collect = a.collect(Collectors.toList());</span><br><span class="line">Map&lt;String, String&gt; collect1 = a.collect(Collectors.toMap(e -&gt; e, e -&gt; e));</span><br><span class="line">Set&lt;String&gt; collect2 = a.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<p>比如这三个方法可以将stream转换成集合形式。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><h3 id="java-util-stream-BaseStream"><a href="#java-util-stream-BaseStream" class="headerlink" title="java.util.stream.BaseStream"></a>java.util.stream.BaseStream</h3><ul>
<li>Iterator<T> iterator()：产生一个用于获取当前流中各个元素的迭代器。这是一种终结操作。</li>
</ul>
<h1 id="收集到映射表中"><a href="#收集到映射表中" class="headerlink" title="收集到映射表中"></a>收集到映射表中</h1><p>假设有一个对象的流<code>Stream&lt;People&gt;</code>，如果想要根据ID获取对应信息，可以使用<code>toMap</code>，但是toMap接受两个参数，键和值，值一般情况下是元素本身，可以使用<code>Function.identity()</code>，当然还要遵循Map的规则，键不能相同，会抛出一个<code>IllegalStateException</code>异常。</p>
<p>如果担心出现这种问题，我们可以对值进行选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.collect(Collectors.toMap(e -&gt; e, e -&gt; e, (old, newValue) -&gt; newValue));</span><br></pre></td></tr></table></figure>

<p>这样就代表，如果出现了主键重复的情况，选择新的value进行覆盖</p>
<p>或者如果你想指定产生的<code>Map</code>为<code>TreeMap</code>，可以使用如下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.collect(Collectors.toMap(e -&gt; e, e -&gt; e, (old, newValue) -&gt; newValue, TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<h1 id="群组和分区"><a href="#群组和分区" class="headerlink" title="群组和分区"></a>群组和分区</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, Set&lt;String&gt;&gt; collect = locales.collect(Collectors.toMap(</span><br><span class="line">        Locale::getDisplayCountry,</span><br><span class="line">        l -&gt; Collections.singleton(l.getDisplayLanguage()),</span><br><span class="line">        (old, newValue) -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; union = <span class="keyword">new</span> HashSet&lt;&gt;(old);</span><br><span class="line">            union.addAll(newValue);</span><br><span class="line">            <span class="keyword">return</span> union;</span><br><span class="line">        &#125;));</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure>

<p>这段代码可以手机给定国家的所有语言，但是有点过于冗长了。</p>
<p>在<code>Java</code>中，将具有相同特性的值群聚成组是很常见的，我们可以使用<code>groupingBy</code>进行这个操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; collect1 = locales.collect(Collectors.groupingBy(Locale::getDisplayCountry));</span><br><span class="line">System.out.println(collect1);</span><br></pre></td></tr></table></figure>

<p>现在我们可以对这个Map进行操作，比如查找中国所用的语言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Locale&gt; Ch = collect1.get(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">System.out.println(Ch);</span><br></pre></td></tr></table></figure>

<p>如果<code>groupingBy</code>中的函数返回值是一个boolean类型，那我们可以使用<code>partitioningBy</code>进行分组，在这种情况下，他要比<code>groupingBy</code>更加高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; map = locales.collect(Collectors.partitioningBy(</span><br><span class="line">        l -&gt; l.getLanguage().equals(<span class="string">&quot;en&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>比如这段代码能够筛选是否使用英语的国家</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><h3 id="java-util-stream-Collector"><a href="#java-util-stream-Collector" class="headerlink" title="java.util.stream.Collector"></a>java.util.stream.Collector</h3><ul>
<li>static&lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt; groupingBy(Function&lt;&gt; super T, ? extends K&gt; classifier)</li>
<li>groupingCurrentMap：产生一个收集器，它会产生一个映射表或并发映射表，键是<code>classifier</code>应用于所有元素上所产生的结果，而值是具有相同键的元素构成的一个个列表</li>
<li>partitioningBy：产生一个收集器，它会产生一个映射表，键是<code>true</code>或<code>false</code>，而值是由断言的段素构成的列表</li>
</ul>
<h1 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h1><p>如果想要返回的值不是一个<code>List</code>而是一个<code>Set</code>，可以使用<code>Collectors.groupingBy(Function, toSet())</code></p>
<p>不仅如此，Java还提供了很多将群组元素约简的方法：</p>
<ul>
<li><p>countings()：对元素个数进行计数</p>
</li>
<li><p>summing(int | long | double)：将函数应用到下游元素中，并计算他们的和</p>
</li>
<li><p>maxBy和minBy：产生一个比较器，并产生最大或最小元素</p>
</li>
<li><p>mapping：产生将函数应用到下游结果上的收集器，并传递给另一个收集器</p>
</li>
<li><p>```java<br>Map&lt;String, Optional<String>&gt; stateToLongestCityName = </p>
<pre><code>cities.collect(
    groupingBy(City::getStat),
    mapping(City::getName,
        maxBy(Comparator.comparing(String::length))));
</code></pre>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">#</span> 约简操作</span><br><span class="line"></span><br><span class="line">在前面介绍过，约简操作是一种终结操作，能够将流转换成非流值，这节中来介绍更多的约简操作：</span><br><span class="line"></span><br><span class="line"><span class="variable">reduce</span>是一种从流中计算某个值的通用操作。比如下面这种操作能够计算<span class="operator">`</span><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">Integer</span><span class="operator">&gt;`</span>集合中的总和</span><br><span class="line"></span><br><span class="line"><span class="operator">```</span><span class="variable">JAVA</span></span><br><span class="line"><span class="built_in">Integer</span><span class="punctuation">[</span><span class="punctuation">]</span> <span class="variable">a</span> <span class="operator">=</span> <span class="variable">new</span> <span class="built_in">Integer</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#123;</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">9</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">Integer</span><span class="operator">&gt;</span> <span class="variable">list</span> <span class="operator">=</span> <span class="built_in">Arrays</span><span class="operator">.</span><span class="variable">asList</span><span class="punctuation">(</span><span class="variable">a</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">Optional</span><span class="operator">&lt;</span><span class="built_in">Integer</span><span class="operator">&gt;</span> <span class="variable">reduce</span> <span class="operator">=</span> <span class="variable">list</span><span class="operator">.</span><span class="variable">stream</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">.</span><span class="variable">reduce</span><span class="punctuation">(</span><span class="built_in">Integer</span><span class="string">::sum</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="variable">System</span><span class="operator">.</span><span class="variable">out</span><span class="operator">.</span><span class="variable">println</span><span class="punctuation">(</span><span class="variable">reduce</span><span class="punctuation">)</span><span class="operator">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在reduce中，还有一项操作非常重要，就是<code>op</code>，这个约简操作会产生<code>v0 op v1 op v2...</code>，其中我们将函数<code>op(v1, v2)</code>写作<code>v1 op v2</code>。这项操作是可结合的，比如将切换顺序，他们的结果应当相同，也就是<code>(v1 op v2) op v3</code>应当与<code>v1 op (v2 op v3)</code>相同。</p>
<p>在reduce操作中，我们经常会使用一个<code>幺元值</code>，这个幺元值能够帮助我们在列表为空时不需要使用<code>Optional</code>进行判空，如果列表为空，那么就会返回这个幺元值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Integer reduce1 = b.stream().reduce(<span class="number">1</span>, Integer::sum);</span><br><span class="line">System.out.println(reduce1);</span><br></pre></td></tr></table></figure>

<p>就像这样，<code>reduce1</code>的值应该是<code>1</code></p>
<p>现在我们需要对一个字符串数组属性进行求和，求出每个字符串长度之和，就不能使用简单的<code>reduce</code>，而是要使用<code>(T1 + T2 ) -&gt; T</code>形式</p>
<p>在实践中，我们更习惯去调用<code>words.mapToInt(String::length).sum()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;GoLang&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;C/C++&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.asList(str).stream().mapToInt(String::length).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<p>在我们使用并行流时，如果使用reduce可能会产生多个类型的计算，我们需要将结果进行合并，可以在reduce中加入第三个方法，表示结果进行合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        Integer reduce3 = Arrays.asList(a).parallelStream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">        System.out.println(reduce3);</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>有时候<code>reduce</code>对我们来说并不够用，比如我们想要搜集<code>BitSet</code>中的结果。如果收集操作是并行的，那么我们就不能将元素放入单个<code>BitSet</code>中，因为<code>BitSet</code>对象并非线程安全的。因此我们不能使用<code>reduce</code>，因为每个部分都需要以自己的空集开始，并且<code>reduce</code>只能提供一个幺元值。在这时候我们更应该使用<code>collect</code>，它能够接受单个引元：</p>
<ul>
<li>一个提供者，它会创建目标类型的新实例，例如散列集的构造器</li>
<li>一个累积器，它会将一个元素添加到一个实例上，例如<code>add</code>方法</li>
<li>一个组合器，能够将两个实例合并成一个，例如<code>addAll</code></li>
</ul>
<p>下面会展示<code>collect</code>如何操作位集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of();</span><br><span class="line">BitSet collect = stream.collect(BitSet::<span class="keyword">new</span>, BitSet::set, BitSet::or);</span><br></pre></td></tr></table></figure>

<h1 id="基本流类型"><a href="#基本流类型" class="headerlink" title="基本流类型"></a>基本流类型</h1><p>到目前为止，我们都是将对象收集到<code>Stream&lt;T&gt;</code>中，对于整数类型，我们一般使用<code>Stream&lt;Integer&gt;</code>，但是这样效率是比较低的，在流库中，有专门的类：</p>
<ul>
<li>IntStream：用于存储short、char、byte和boolean</li>
<li>LongStream</li>
<li>DoubleStream：存储float类型</li>
</ul>
<p>用于存储基本类型值，无需使用包装器。</p>
<p>为了创建IntStream，我们可以使用<code>of</code>或<code>Arrays.stream()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">IntStream intStream = IntStream.of(numbers);</span><br><span class="line">intStream = Arrays.stream(numbers);</span><br></pre></td></tr></table></figure>

<p>和对象流一样，IntStream和LongStream也可以通过<code>generate</code>或者<code>iterator</code>创建无限流；此外，还有两个静态方法<code>range</code>和<code>rangeClose</code>，可以用于生成步长为1的整数范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">0</span>, <span class="number">100</span>); </span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>CharSequence</code>接口有<code>codePoints()</code>和<code>chars</code>方法，可以生成由字符的<code>Unicode</code>码或<code>UTF-16</code>编码所组成的IntStream</p>
<p>假如我们现在已经有了一个对象流，想将这个对象流转换成基本类型流，可以通过<code>mapToInt/Long/Double</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;GoLang&quot;</span>);</span><br><span class="line">IntStream intStream2 = stream.mapToInt(String::length);</span><br><span class="line">System.out.println(Arrays.toString(intStream2.toArray()));</span><br></pre></td></tr></table></figure>

<p>比如这串代码能够将字符串的长度作为元素放入<code>IntStream</code></p>
<p>如果想将基本类型流转换成对象流，可以使用<code>boxed</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream3 = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">6</span>);</span><br><span class="line">Stream&lt;Integer&gt; boxed = intStream3.boxed();</span><br></pre></td></tr></table></figure>

<p>基本类型流基本上的方法和对象流类似，最主要的差异有：</p>
<ul>
<li><code>toArray</code>方法会返回基本类型数组</li>
<li>产生可选结果的方法会返回<code>OptionalInt/Long/Double</code>，这些方法与<code>Optional</code>类似，但是有<code>getAsInt/Long/Double</code>方法，而不是get</li>
<li>具有返回总和、平均值、最大值、最小值的<code>sum</code>、<code>average</code>、<code>max</code>、<code>min</code>方法，而对象流没有这些</li>
<li><code>summaryStatistics</code>方法会产生一个类型为<code>Int/Long/DoubleSummaryStatistics</code>对象，他们可以同时报告流的总和、平均值、最大值和最小值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics intSummaryStatistics = intStream3.summaryStatistics();</span><br><span class="line">System.out.println(intSummaryStatistics);</span><br><span class="line"></span><br><span class="line"><span class="comment">//IntSummaryStatistics&#123;count=5, sum=57, min=1, average=11.400000, max=45&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>这章所涉及的API比较多</p>
<h3 id="java-util-stream-IntStream"><a href="#java-util-stream-IntStream" class="headerlink" title="java.util.stream.IntStream"></a>java.util.stream.IntStream</h3><ul>
<li>range()</li>
<li>rangeClosed()：产生一个由给定范围内的整数所构成的<code>IntStream</code>，区别在于<code>rangeClosed</code>包含最后的结束节点，range不包含</li>
<li>of(int… values)：产生由给定元素组成的流</li>
<li>toArray()：将当前流转换成数组</li>
<li>sum()</li>
<li>max()</li>
<li>min()</li>
<li>average()</li>
<li>summaryStatistics()：产生当前流中元素的总和、最大值、最小值、平均值，或是包含着四种值的对象</li>
<li>boxed()：将基本类型流转换成对象流</li>
</ul>
<h3 id="java-util-stream-LongStream"><a href="#java-util-stream-LongStream" class="headerlink" title="java.util.stream.LongStream"></a>java.util.stream.LongStream</h3><h3 id="java-util-stream-DoubleStream"><a href="#java-util-stream-DoubleStream" class="headerlink" title="java.util.stream.DoubleStream"></a>java.util.stream.DoubleStream</h3><p>用法和IntStream一致</p>
<h3 id="java-lang-CharSequence"><a href="#java-lang-CharSequence" class="headerlink" title="java.lang.CharSequence"></a>java.lang.CharSequence</h3><p>String类型实现了<code>CharSequence</code>接口</p>
<ul>
<li>codePoints()：将当前字符串中所有的<code>Unicode</code>码点构成流</li>
</ul>
<h3 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h3><ul>
<li>ints()</li>
<li>ints(int begin, int end)</li>
<li>ints(long size)</li>
<li>ints(long size, int begin, int end)</li>
<li>longs()…..</li>
<li>doubles()……</li>
<li>产生随机数流，如果提供了size，这个刘就是具有给定元素数量的有限流，当提供了边界时，其元素位于<code>begin</code>和<code>end</code>之间</li>
</ul>
<h3 id="java-util-Optional-Int-Long-Double"><a href="#java-util-Optional-Int-Long-Double" class="headerlink" title="java.util.Optional(Int/Long/Double)"></a>java.util.Optional(Int/Long/Double)</h3><ul>
<li>of(T value)：用提供的基本数据类型产生一个可选对象</li>
<li>getAsT()：产生当前可选对象的值，如果不存在抛出<code>NoSuchElementException</code>异常</li>
<li>orElse(value)：返回可选对象值，如果不存在返回value</li>
<li>orElseGet(Supplier other)：产生当前可选对象的值，如果不存在，产生可替换的值</li>
<li>isPresent(Consumer c)：如果当前可选对象不为空，将值传递给c</li>
</ul>
<h3 id="java-util-Int-Long-Double-SummaryStatistics"><a href="#java-util-Int-Long-Double-SummaryStatistics" class="headerlink" title="java.util.(Int/Long/Double) SummaryStatistics"></a>java.util.(Int/Long/Double) SummaryStatistics</h3><ul>
<li>getCount()</li>
<li>getSum()</li>
<li>getAverage()</li>
<li>getMax()</li>
<li>getMin()</li>
<li>产生收集到的元素个数、总和、平均值、最大值、最小值</li>
</ul>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>流使得并行处理块操作变得很容易，但是需要遵循一些规则，首先是产生一个并行流，有两种方式可以产生并行流：</p>
<ul>
<li>parallelStream()：可以从任何集合中获取一个并行流</li>
<li>parallel()：将流转换成并行流</li>
</ul>
<p>只要在终结方法执行时，流处于并行模式，那么所有的中间流操作都将被并行化</p>
<p>当流操作并行运行时，其目标时要让其返回结果与顺序执行时返回的结果相同。重要的是，这些操作可以以任意顺序执行。</p>
<p>来看这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="keyword">int</span>[] shrtWords = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">stream.parallel().forEach(e -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.length() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        shrtWords[e.length()]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(shrtWords);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这是一种很糟糕的代码，传递给forEach的函数会在多个并发线程中运行，每个都会更新共享的数组。当数据量稍微大那么一点点时，运行出来的数据就会产生不同的结果。</p>
<p>我们并不需要错误的结果，就需要保证传递给并行流的操作安全的并行执行，而达到这个目的的最佳方式是原理易变状态。</p>
<p>在本例中，我们可以用长度将字符串群组，然后分别对他们进行计数，就可以安全的并行化这项计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Long&gt; collect =</span><br><span class="line">        stream.parallel().filter(s -&gt; s.length() &lt; <span class="number">12</span>)</span><br><span class="line">                .collect(Collectors.groupingBy(String::length, Collectors.counting()));</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure>

<p>默认情况下，从有序集合、范围、生成器和迭代产生的流，或者通过调用<code>Stream.sorted</code>产生的流，都是有序的。</p>
<p>排序并不排斥高效的并行处理，例如，当计算<code>stream.map(fun)</code>时，流可以被划分为n个部分，他们会被并行处理，然后按照顺序重新组装起来。</p>
<p>当我们放弃排序需求时，有些操作可以被更加高效的并行化。通过在流上游调用<code>unordered</code>方法，可以标明我们对排序不感兴趣。<code>distinct</code>就是从这种方式中获益的一种操作，在有序流中，<code>distinct</code>会保留所有元素中的第一个，这是对并行化的一种阻碍。在所有线程都处理完之前，我们不知道应该丢弃哪些元素。如果可以接受保留唯一元素中任意一个的做法，那么所有部分就可以并行处理。</p>
<p>还有放弃排序来提高<code>limit</code>速度。</p>
<p>我们需要知道，合并映射表的代价是非常高的，正是这个原因，<code>Collectors.groupingByConcurrent</code>方法使用了共享的并发映射表。为了从并行化中受益，映射表中值的顺序不会与流中的顺序相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;Integer, List&lt;String&gt;&gt; collect1 = stream.parallel().collect(Collectors.groupingByConcurrent(String::length));</span><br></pre></td></tr></table></figure>

<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>不要试图将一个集合生成流之后，再修改这个集合，此时流不会收集他们的元素，准确来说，流操作都是惰性的，直到终结操作时才对集合进行修改才是可行的。</p>
<p>为了让并行流正常工作，需要满足以下条件：</p>
<ul>
<li>数据应该存在内存中，必须等数据到达是非常低效的</li>
<li>流可以被高效分为若干个子部分，由数组或平衡二叉树支撑的流都可以工作的很好，但是<code>iterate</code>返回的结果不行</li>
<li>流操作的工作量应该具有较大的规模，如果总工作负载并不是很大，那么搭建并行计算时所付出的代价就没有什么意义。</li>
<li>流操作不应该被阻塞。</li>
</ul>
<p>换句话说，不要讲所有的流操作都转化成并行流，只有在对已经位于内存中，并且数据执行大量计算操作时，才应该使用并行流。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><h3 id="java-util-stream-BaseStream-1"><a href="#java-util-stream-BaseStream-1" class="headerlink" title="java.util.stream.BaseStream"></a>java.util.stream.BaseStream</h3><ul>
<li>parallel()：产生一个与当前流中元素相同的并行流</li>
<li>unordered()：产生一个与当前流中元素相同的无序流</li>
</ul>
<h3 id="java-util-Collection"><a href="#java-util-Collection" class="headerlink" title="java.util.Collection"></a>java.util.Collection</h3><ul>
<li>parallelStream()：使用当前集合中的元素产生一个并行流</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/JiangLiuJL">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=ZJIyoBCxTJBHdyrsTC-0bZ6_wV7v8ztt&amp;noverify=0">联系我</a></span>
        <span>/</span>
        
        <span><a href="https://jiangliujl.github.io/about/">JiangLiu&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
    data-repo="aircloud/hexo-aircloud-blog"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjkwNDgyNjg="
    data-category="Announcements"
    data-category-id="DIC_kwDOB7EezM4COhKJ"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async>
</script>




</html>
